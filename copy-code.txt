File: app/page.tsx
================================================================================
"use client";
import { useState, useEffect } from "react";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { Slider } from "@/components/ui/slider";
import { Checkbox } from "@/components/ui/checkbox";
import { Card } from "@/components/ui/card";
import { Select, SelectTrigger, SelectValue, SelectContent, SelectItem } from "@/components/ui/select";
import { ModelViewer } from "@/components/model-viewer";
import { PredictionsGrid } from "@/components/predictions-grid";
import { Upload, Download, X, CheckCircle2, Image as ImageIcon, ChevronUp, ChevronDown, ChevronRight, Settings, FolderPlus, Github, LayoutGrid } from "lucide-react";
import Image from "next/image";
import { generateModel, uploadImage, getProjects } from "./actions";
import PasswordLock from "@/components/password-lock";
import { toast } from "sonner";
import { ImageGeneration } from "@/components/image-generation";
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from "@/components/ui/collapsible";
import { MobileGallery } from "@/components/mobile-gallery";
import { ProjectDialog } from "@/components/project-dialog";
import { Label } from "@/components/ui/label";
import Link from "next/link";
import { useTheme } from "next-themes";
import { useDropzone } from "react-dropzone";
import { Project } from "@/types/database";

function UploadZone({ onUploadComplete, onError, currentCount, maxImages }) {
  const [uploading, setUploading] = useState(false);
  const handleDrop = async (acceptedFiles) => {
    if (acceptedFiles.length === 0) return;
    const allowedCount = Math.min(acceptedFiles.length, maxImages - currentCount);
    if (allowedCount <= 0) {
      onError("Maximum number of images reached");
      return;
    }
    setUploading(true);
    const filesToProcess = acceptedFiles.slice(0, allowedCount);
    await Promise.all(
      filesToProcess.map(async (file) => {
        if (!file.type.startsWith("image/")) {
          onError("Invalid image");
          return;
        }
        try {
          const formData = new FormData();
          formData.append("image", file);
          const result = await uploadImage(formData);
          if (result.url) {
            onUploadComplete(result.url);
          }
        } catch (_) {
          onError("Upload failed");
        }
      })
    );
    setUploading(false);
  };
  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop: handleDrop,
    accept: { "image/*": [".png", ".jpg", ".jpeg", ".gif", ".webp"] },
    maxSize: 32 * 1024 * 1024,
    multiple: true,
  });
  return (
    <div
      {...getRootProps()}
      className={`relative flex flex-col items-center justify-center w-full h-20 border-2 border-dashed rounded-lg cursor-pointer transition-colors duration-200 ease-in-out ${
        isDragActive ? "border-primary bg-primary/5" : "border-muted-foreground/25"
      } hover:border-primary hover:bg-primary/5`}
    >
      <input {...getInputProps()} />
      <Upload className={`w-5 h-5 ${uploading ? "animate-pulse" : ""} text-muted-foreground`} />
      <p className="text-xs text-muted-foreground mt-1">
        {uploading ? "Uploading..." : isDragActive ? "Drop" : "Upload"}
      </p>
    </div>
  );
}

export default function ModelGenerator() {
  const [activeTab, setActiveTab] = useState("upload");
  const [loading, setLoading] = useState(false);
  const [imageUrls, setImageUrls] = useState<string[]>([]);
  const [modelUrl, setModelUrl] = useState("");
  const [error, setError] = useState("");
  const [success, setSuccess] = useState(false);
  const [pendingSubmissions, setPendingSubmissions] = useState<any[]>([]);
  const [autoGenerateMeshes, setAutoGenerateMeshes] = useState(false);
  const [gridExpanded, setGridExpanded] = useState(false);
  const [settingsOpen, setSettingsOpen] = useState(false);
  const [mobileGalleryOpen, setMobileGalleryOpen] = useState(false);
  const [projectDialogOpen, setProjectDialogOpen] = useState(false);
  const [currentProjectId, setCurrentProjectId] = useState<string | null>(null);
  const [projects, setProjects] = useState<any[]>([]);
  const [desktopGalleryOpen, setDesktopGalleryOpen] = useState(false);
  const [formData, setFormData] = useState({
    steps: 50,
    guidance_scale: 5.5,
    seed: Math.floor(Math.random() * 10000),
    octree_resolution: 256,
    remove_background: true,
  });
  const { theme } = useTheme();
  const isDarkMode = theme === "dark";

  useEffect(() => {
    const loadProjects = async () => {
      try {
        const projectsList = await getProjects();
        setProjects(projectsList);
      } catch (error) {
        console.error("Failed to load projects:", error);
      }
    };
    loadProjects();
  }, []);

  async function processPredictionsConcurrently(urls: string[], concurrency: number) {
    if (!currentProjectId) {
      toast.error("Please select or create a project first");
      return [];
    }
    const results: any[] = [];
    let currentIndex = 0;
    const newPendingSubmissions = urls.map((url, idx) => ({
      id: `pending-${Date.now()}-${idx}`,
      status: "starting",
      input: { image: url, octree_resolution: formData.octree_resolution },
      created_at: new Date().toISOString(),
      project_id: currentProjectId,
    }));
    setPendingSubmissions((prev) => [...newPendingSubmissions, ...prev]);
    async function worker() {
      while (currentIndex < urls.length) {
        const index = currentIndex++;
        try {
          results[index] = await generateModel({
            image: urls[index],
            ...formData,
            project_id: currentProjectId,
          });
        } catch (error) {
          results[index] = { error };
        }
      }
    }
    const numWorkers = Math.min(concurrency, urls.length);
    const workers = [];
    for (let i = 0; i < numWorkers; i++) {
      workers.push(worker());
    }
    await Promise.all(workers);
    return results;
  }

  const handleSubmit = async (e?: React.FormEvent<HTMLFormElement>) => {
    if (e) e.preventDefault();
    if (!currentProjectId) {
      toast.error("Please select or create a project first");
      setProjectDialogOpen(true);
      return;
    }
    if (imageUrls.length === 0) return;
    setLoading(true);
    setError("");
    setSuccess(false);
    try {
      const results = await processPredictionsConcurrently(imageUrls, 10);
      if (!results.length) {
        setError("Generation failed");
        return;
      }
      const allFailed = results.every((r) => r.error);
      if (allFailed) {
        setError("Generation failed");
        toast.error("3D model generation failed");
      } else {
        setSuccess(true);
        toast.success("3D model generation started!");
        setTimeout(() => setSuccess(false), 5000);
      }
      setImageUrls([]);
    } catch (err: any) {
      setError("Generation failed");
      toast.error("Error: " + (err.message || "Unknown error"));
    } finally {
      setLoading(false);
    }
  };

  const removeImage = (url: string) => {
    setImageUrls((prev) => prev.filter((img) => img !== url));
  };

  const handleImagesGenerated = (urls: string[]) => {
    setImageUrls(urls);
    if (urls.length > 0 && autoGenerateMeshes && currentProjectId) {
      handleSubmit();
    }
  };

  const handleImageGenerationSubmit = (submissions: any[]) => {
    if (submissions && submissions.length > 0) {
      setPendingSubmissions((prev) => [...submissions, ...prev]);
    }
  };

  const handleProjectCreated = (projectId: string, projectName: string) => {
    setCurrentProjectId(projectId);
    setProjects((prev) => [
      {
        id: projectId,
        name: projectName,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      },
      ...prev,
    ]);
    setProjectDialogOpen(false);
    toast.success(`Project "${projectName}" created`);
  };

  const figmaColors = { purple: "#A259FF", red: "#F24E1E", blue: "#1ABCFE", green: "#0ACF83" };

  return (
    <PasswordLock>
      <div className="relative h-[100dvh] w-full overflow-hidden flex flex-col">
        <div className="border-b">
          <div className="flex h-14 items-center px-4 max-w-screen-2xl mx-auto">
            <div className="flex items-center space-x-2 font-semibold text-xl">
              <img
                src={isDarkMode ? "https://i.ibb.co/v4wcBzGK/logo-default.png" : "https://i.ibb.co/BV7rr4z2/logo-default.png"}
                alt="ArchiFigure Logo"
                className="h-8 w-auto"
              />
            </div>
            <div className="ml-auto flex items-center space-x-4">
              <Button variant="ghost" size="icon" className="md:hidden" onClick={() => setMobileGalleryOpen(true)}>
                <LayoutGrid className="h-5 w-5" />
              </Button>
              <Button variant="ghost" size="icon" className="hidden md:inline-flex" onClick={() => setDesktopGalleryOpen(true)}>
                <LayoutGrid className="h-5 w-5" />
              </Button>
              <Link href="https://github.com/lukketsvane/archifigure/" target="_blank" rel="noreferrer" className="text-sm text-muted-foreground hover:text-foreground transition-colors">
                <Github className="h-5 w-5" />
              </Link>
            </div>
          </div>
        </div>
        
        <MobileGallery
          isOpen={mobileGalleryOpen}
          onClose={() => setMobileGalleryOpen(false)}
          onSelectModel={(meshUrl, inputImage, resolution) => {
            setModelUrl(meshUrl);
            if (inputImage) setImageUrls([inputImage]);
            if (resolution) {
              setFormData((prev) => ({ ...prev, octree_resolution: resolution }));
            }
          }}
          pendingSubmissions={pendingSubmissions}
          currentProjectId={currentProjectId}
          onCreateProject={() => setProjectDialogOpen(true)}
        />
        
        {desktopGalleryOpen && (
          <div className="fixed inset-0 z-50 bg-background flex flex-col">
            <div className="flex justify-between items-center p-4 border-b">
              <h2 className="text-lg font-medium">Gallery</h2>
              <Button variant="ghost" size="icon" onClick={() => setDesktopGalleryOpen(false)}>
                <X className="h-5 w-5" />
              </Button>
            </div>
            <div className="flex-1 overflow-auto p-4">
              <PredictionsGrid
                onSelectModel={(meshUrl, inputImage, resolution) => {
                  setModelUrl(meshUrl);
                  if (inputImage) setImageUrls([inputImage]);
                  if (resolution) {
                    setFormData((prev) => ({ ...prev, octree_resolution: resolution }));
                  }
                  setDesktopGalleryOpen(false);
                }}
                pendingSubmissions={pendingSubmissions}
                currentProjectId={currentProjectId}
                onCreateProject={() => setProjectDialogOpen(true)}
              />
            </div>
          </div>
        )}
        
        <ProjectDialog
          open={projectDialogOpen}
          onOpenChange={setProjectDialogOpen}
          onProjectCreated={handleProjectCreated}
        />
        
        <div className="flex-1 flex flex-col lg:flex-row overflow-hidden">
          <div className="w-full lg:w-[350px] lg:min-w-[350px] p-4 overflow-y-auto border-r">
            <Card className="p-4 border">
              <Tabs defaultValue="upload">
                <TabsList className="grid grid-cols-2 mb-4">
                  <TabsTrigger value="upload">Last opp</TabsTrigger>
                  <TabsTrigger value="instructions">Instruksjonar</TabsTrigger>
                </TabsList>
                
                <TabsContent value="upload" className="space-y-4">
                  <div className="flex items-center justify-between">
                    <Label htmlFor="project" className="text-xs">Vald prosjekt</Label>
                    <Button 
                      variant="ghost" 
                      size="icon" 
                      className="h-7 w-7"
                      onClick={() => setProjectDialogOpen(true)}
                    >
                      <FolderPlus className="h-4 w-4" />
                    </Button>
                  </div>
                  
                  {currentProjectId ? (
                    <div className="text-sm px-2 py-1 bg-muted rounded-md">
                      {projects?.find(p => p.id === currentProjectId)?.name || "Loading project..."}
                    </div>
                  ) : (
                    <Button 
                      variant="outline" 
                      className="w-full justify-center text-muted-foreground"
                      onClick={() => setProjectDialogOpen(true)}
                    >
                      <FolderPlus className="h-4 w-4 mr-2" />
                      Lag Prosjekt
                    </Button>
                  )}
                
                  <form onSubmit={handleSubmit} className="space-y-3">
                    <div className="space-y-2">
                      <UploadZone
                        onUploadComplete={(url) => setImageUrls((prev) => [...prev, url])}
                        onError={(msg) => {
                          setError(msg);
                          toast.error(msg);
                        }}
                        currentCount={imageUrls.length}
                        maxImages={10}
                      />
                      
                      <div className="pt-2">
                        <ImageGeneration 
                          onImagesGenerated={handleImagesGenerated} 
                          onSubmit={handleImageGenerationSubmit}
                          forcedAspectRatio="1:1"
                          useMostPermissiveSafetyLevel={true}
                          useImagen3={true}
                        />
                      </div>
                    </div>
                    
                    <Collapsible open={settingsOpen} onOpenChange={setSettingsOpen}>
                      <CollapsibleTrigger asChild>
                        <Button variant="ghost" size="sm" className="flex w-full justify-start px-2 text-xs text-muted-foreground hover:text-foreground">
                          <Settings className="h-3.5 w-3.5 mr-2" />
                          <span>Avanserte innstillingar</span>
                          <ChevronRight className={`h-3.5 w-3.5 ml-auto transition-transform ${settingsOpen ? "rotate-90" : ""}`} />
                        </Button>
                      </CollapsibleTrigger>
                      
                      <CollapsibleContent className="pt-2 space-y-3">
                        <div className="space-y-2 pt-1">
                          <Slider
                            id="steps"
                            min={20}
                            max={50}
                            step={1}
                            value={[formData.steps]}
                            onValueChange={([steps]) => setFormData({ ...formData, steps })}
                            className="py-0.5"
                          />
                          <div className="flex justify-between text-xs text-muted-foreground">
                            <span>Steg: {formData.steps}</span>
                          </div>
                        </div>
                        
                        <div className="space-y-2">
                          <Slider
                            id="guidance"
                            min={1}
                            max={20}
                            step={0.1}
                            value={[formData.guidance_scale]}
                            onValueChange={([guidance_scale]) => setFormData({ ...formData, guidance_scale })}
                            className="py-0.5"
                          />
                          <div className="flex justify-between text-xs text-muted-foreground">
                            <span>Rettleiing: {formData.guidance_scale.toFixed(1)}</span>
                          </div>
                        </div>
                        
                        <div className="flex justify-between gap-2">
                          <div className="flex-1">
                            <div className="flex">
                              <input
                                type="number"
                                value={formData.seed}
                                onChange={(e) => setFormData({ ...formData, seed: Number(e.target.value) })}
                                className="h-8 w-full bg-background rounded-l-md border border-input px-3 py-2 text-xs ring-offset-background"
                              />
                              <Button 
                                type="button"
                                size="icon" 
                                variant="outline" 
                                className="h-8 w-8 rounded-l-none"
                                onClick={() => setFormData({...formData, seed: Math.floor(Math.random() * 10000)})}
                              >
                                游
                              </Button>
                            </div>
                            <div className="text-xs text-muted-foreground mt-1">Seed</div>
                          </div>
                          
                          <div className="flex-1">
                            <Select
                              value={formData.octree_resolution.toString()}
                              onValueChange={(value) => setFormData({ ...formData, octree_resolution: Number(value) })}
                            >
                              <SelectTrigger className="h-8 text-xs">
                                <SelectValue />
                              </SelectTrigger>
                              <SelectContent>
                                <SelectItem value="256">256 - rask</SelectItem>
                                <SelectItem value="384">384 - Medium</SelectItem>
                                <SelectItem value="512">512 - detaljert</SelectItem>
                              </SelectContent>
                            </Select>
                            <div className="text-xs text-muted-foreground mt-1">Quality</div>
                          </div>
                        </div>
                        
                        <div className="flex items-center space-x-2">
                          <Checkbox
                            id="background"
                            checked={formData.remove_background}
                            onCheckedChange={(checked) =>
                              setFormData({ ...formData, remove_background: checked as boolean })
                            }
                          />
                          <span className="text-xs">Fjern Bakgrunn</span>
                        </div>
                        
                        <div className="flex items-center space-x-2">
                          <Checkbox
                            id="autoGenerate"
                            checked={autoGenerateMeshes}
                            onCheckedChange={(checked) => setAutoGenerateMeshes(checked as boolean)}
                          />
                          <span className="text-xs">Automatisk generer figurar</span>
                        </div>
                      </CollapsibleContent>
                    </Collapsible>
                    
                    <Button
                      type="submit"
                      className="w-full h-10 text-sm relative overflow-hidden"
                      style={{ 
                        background: loading || !currentProjectId 
                          ? "#666" 
                          : `linear-gradient(90deg, ${figmaColors.blue}, ${figmaColors.purple})` 
                      }}
                      disabled={loading || imageUrls.length === 0 || !currentProjectId}
                    >
                      <span className="mr-auto">
                        {loading ? (
                          <span className="flex items-center">
                            <span className="h-4 w-4 mr-2 animate-spin rounded-full border-2 border-white border-t-transparent" />
                            Snekrar modell
                          </span>
                        ) : !currentProjectId ? (
                          "Opprett eit Prosjekt fyrst"
                        ) : (
                          "Lag 3D modell"
                        )}
                      </span>
                    </Button>
                  </form>
                </TabsContent>
                <TabsContent value="instructions" className="space-y-4">
                  <div className="space-y-3 text-sm">
                    <h2 className="text-lg font-medium">Korleis bruke tenesta</h2>
                    
                    <div className="space-y-2">
                      <h3 className="font-medium">1. Lag eit prosjekt</h3>
                      <p className="text-muted-foreground text-xs">Start med 친 lage eit prosjekt for 친 organisere 3D-modellane dine.</p>
                    </div>
                    
                    <div className="space-y-2">
                      <h3 className="font-medium">2. F친 eit bilete</h3>
                      <p className="text-muted-foreground text-xs">Last opp ditt eige bilete av ein person, eller bruk tekstgeneratoren til 친 lage eitt.</p>
                    </div>
                    
                    <div className="space-y-2">
                      <h3 className="font-medium">3. Generer 3D-modell</h3>
                      <p className="text-muted-foreground text-xs">N친r du har eit bilete, klikk p친 "Generer 3D-modell" for 친 lage ein 3D-figur.</p>
                    </div>
                    
                    <div className="space-y-2">
                      <h3 className="font-medium">4. Sj친 og last ned</h3>
                      <p className="text-muted-foreground text-xs">N친r prosessen er ferdig, kan du sj친 3D-modellen og laste ned GLB-fila for bruk i arkitekturprosjekta dine.</p>
                    </div>
                    
                    <div className="bg-muted/50 p-3 rounded-md">
                      <div className="flex gap-2">
                        <div className="text-xs">
                          <p className="font-medium">Gode tips:</p>
                          <ul className="list-disc ml-4 mt-1 space-y-1 text-muted-foreground">
                            <li>Bruk bilete med enkel bakgrunn</li>
                            <li>Sj친 til at heile kroppen er synleg</li>
                            <li>For arkitektur er st친ande figurar best</li>
                            <li>Bruk 256 for raskare generering, 512 for meir detaljar</li>
                          </ul>
                        </div>
                      </div>
                    </div>
                  </div>
                </TabsContent>
              </Tabs>
            </Card>
          </div>
          
          <div className="flex-1 flex flex-col overflow-hidden">
            <div className="flex-1 p-4 overflow-y-auto relative">
              <Card className="w-full h-full relative overflow-hidden border">
                {modelUrl ? (
                  <div className="absolute inset-0">
                    <ModelViewer
                      url={modelUrl}
                      inputImage={imageUrls[0]}
                      resolution={formData.octree_resolution}
                      currentProjectId={currentProjectId}
                      onProjectSelect={setCurrentProjectId}
                    />
                  </div>
                ) : (
                  <div className="absolute inset-0 flex flex-col items-center justify-center bg-muted/30">
                    {loading ? (
                      <div className="flex flex-col items-center space-y-2">
                        <div className="h-10 w-10 animate-spin rounded-full border-4 border-primary border-t-transparent" />
                        <p className="text-sm text-muted-foreground">Snekrar figur...</p>
                      </div>
                    ) : imageUrls.length > 0 ? (
                      <div className="w-full h-full grid grid-cols-2 md:grid-cols-3 gap-3 p-4 overflow-auto">
                        {imageUrls.map((url) => (
                          <div key={url} className="relative border rounded aspect-square overflow-hidden">
                            <Image
                              src={url || "/placeholder.svg"}
                              alt="Input"
                              fill
                              className="object-cover"
                              unoptimized
                            />
                            <Button
                              type="button"
                              variant="ghost"
                              size="icon"
                              className="absolute top-1 right-1 h-5 w-5 rounded-full bg-background/70 hover:bg-background/90"
                              onClick={() => removeImage(url)}
                            >
                              <X className="h-3 w-3" />
                            </Button>
                          </div>
                        ))}
                      </div>
                    ) : (
                      <div className="flex flex-col items-center space-y-3 max-w-sm text-center p-6">
                        <div className="mt-8 border-t pt-4 w-full">
                          <div className="flex justify-center">
                            <img 
                              src="https://i.ibb.co/qzd8ZXp/vipps.jpg" 
                              alt="vipps" 
                              className="w-64 h-64 object-contain rounded-lg" 
                            />
                          </div>
                          <div className="mt-4">
                            <p className="text-sm text-muted-foreground mb-2">
                              V칝r grei 친 vipps en kopp kaffi, det koster meg noen kroner hver gang du lager en modell
                            </p>
                          </div>
                        </div>
                      </div>
                    )}
                  </div>
                )}
              </Card>
            </div>
            <div className={`border-t transition-all duration-300 ease-in-out ${gridExpanded ? 'h-[70vh]' : 'h-12'} hidden md:block`}>
              <div className="flex items-center justify-between px-4 h-12 bg-muted/40">
                <span className="text-sm font-medium">Gallery</span>
                <Button
                  variant="ghost" 
                  size="icon"
                  className="h-8 w-8"
                  onClick={() => setGridExpanded(!gridExpanded)}
                >
                  {gridExpanded ? <ChevronDown className="h-4 w-4" /> : <ChevronUp className="h-4 w-4" />}
                </Button>
              </div>
              
              {gridExpanded && (
                <div className="h-[calc(70vh-3rem)] overflow-hidden">
                  <PredictionsGrid
                    onSelectModel={(meshUrl, inputImage, resolution) => {
                      setModelUrl(meshUrl);
                      if (inputImage) setImageUrls([inputImage]);
                      if (resolution)
                        setFormData((prev) => ({ ...prev, octree_resolution: resolution }));
                    }}
                    pendingSubmissions={pendingSubmissions}
                    currentProjectId={currentProjectId}
                    onCreateProject={() => setProjectDialogOpen(true)}
                  />
                </div>
              )}
            </div>
          </div>
        </div>
      </div>
    </PasswordLock>
  );
}
--------------------------------------------------------------------------------
File: app/layout.tsx
================================================================================
import "./globals.css";
import { Inter } from "next/font/google";
import { ThemeProvider } from "@/components/theme-provider";
import { Toaster } from "sonner";
import { Navbar } from "@/components/navbar";

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "ArchiFigure - 3D-figurar for arkitekturmodellar",
  description: "Generer 3D-menneskefigurar til arkitekturmodellane dine",
};

interface RootLayoutProps {
  children: React.ReactNode;
}

export default function RootLayout({ children }: RootLayoutProps) {
  return (
    <html lang="nn">
      <body className={inter.className}>
        <ThemeProvider>
          <div className="flex flex-col min-h-screen">
            <main className="flex-1">{children}</main>
          </div>
          <Toaster position="top-right" />
        </ThemeProvider>
      </body>
    </html>
  );
}
--------------------------------------------------------------------------------
File: components/prompt-generator.tsx
================================================================================
"use client";

import { useState, useEffect, useRef, useCallback } from "react";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Plus, X, Info, Check } from "lucide-react";
import { Textarea } from "@/components/ui/textarea";
import { Card } from "@/components/ui/card";
import { Label } from "@/components/ui/label";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { toast } from "sonner";

export function PromptGenerator({ onGenerateImages }) {
  // Changed default prompt
  const defaultPrompt = "full frame image of a single {person} scandinavian {pose}";
  // Updated suffix
  const promptSuffix = ", full standing body, head to toe view, studio lighting, set stark against a solid white background";
  
  const [basePrompt, setBasePrompt] = useState(defaultPrompt);
  const [lists, setLists] = useState({});
  const [detectedLists, setDetectedLists] = useState([]);
  const [newTag, setNewTag] = useState("");
  const [activeListId, setActiveListId] = useState(null);
  const [editingTag, setEditingTag] = useState({ listId: null, index: null, value: "" });
  const [generatedPrompts, setGeneratedPrompts] = useState([]);
  const editInputRef = useRef(null);

  // Detect any {text} patterns in the prompt
  useEffect(() => {
    const regex = /\{([^}]+)\}/g;
    const matches = [...basePrompt.matchAll(regex)];
    const listIdentifiers = [...new Set(matches.map(match => match[1].trim()))];
    
    setDetectedLists(listIdentifiers);
    
    // Initialize lists object
    const newLists = { ...lists };
    listIdentifiers.forEach(id => {
      if (!newLists[id]) {
        newLists[id] = [];
      }
    });
    
    // Remove lists that are no longer in the prompt
    Object.keys(newLists).forEach(key => {
      if (!listIdentifiers.includes(key)) {
        delete newLists[key];
      }
    });
    
    setLists(newLists);
  }, [basePrompt]);

  // Add example tags when component loads with default prompt
  useEffect(() => {
    if (basePrompt === defaultPrompt && 
        detectedLists.includes("person") && 
        detectedLists.includes("pose") &&
        (!lists["person"] || lists["person"].length === 0) && 
        (!lists["pose"] || lists["pose"].length === 0)) {
      // Reduced to 2 elements per list
      setLists({
        "person": ["woman", "man"],
        "pose": ["standing", "walking"]
      });
    }
  }, [basePrompt, lists, defaultPrompt, detectedLists]);

  // Focus on edit input when editing starts
  useEffect(() => {
    if (editingTag.listId && editInputRef.current) {
      editInputRef.current.focus();
    }
  }, [editingTag]);

  // Process tag with multiplier syntax (tag*n)
  const processTagWithMultiplier = (tag) => {
    const multiplierMatch = tag.match(/^(.+)\*(\d+)$/);
    if (multiplierMatch) {
      const baseTag = multiplierMatch[1].trim();
      const count = parseInt(multiplierMatch[2], 10);
      return Array(count).fill(baseTag);
    }
    return [tag];
  };

  // Add a new tag to a list
  const addTag = (listId, tagText) => {
    if (!tagText?.trim()) return;
    
    const processedTags = processTagWithMultiplier(tagText.trim());
    
    setLists(prev => ({
      ...prev,
      [listId]: [...(prev[listId] || []), ...processedTags]
    }));
  };

  // Remove a tag from a list
  const removeTag = (listId, index) => {
    setLists(prev => ({
      ...prev,
      [listId]: prev[listId].filter((_, i) => i !== index)
    }));
  };

  // Start editing a tag
  const startEditTag = (listId, index, value) => {
    setEditingTag({ listId, index, value });
  };

  // Complete tag editing
  const completeTagEdit = () => {
    if (editingTag.listId && editingTag.value.trim()) {
      setLists(prev => {
        const newList = [...prev[editingTag.listId]];
        newList[editingTag.index] = editingTag.value.trim();
        return { ...prev, [editingTag.listId]: newList };
      });
    }
    setEditingTag({ listId: null, index: null, value: "" });
  };

  // Handle key press in tag editing
  const handleEditKeyPress = (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      completeTagEdit();
    } else if (e.key === 'Escape') {
      setEditingTag({ listId: null, index: null, value: "" });
    }
  };

  // Generate all prompt permutations
  const generatePermutations = useCallback(() => {
    // Check if all detected lists have at least one tag
    const allListsHaveTags = detectedLists.every(list => lists[list] && lists[list].length > 0);
    
    if (!allListsHaveTags) {
      toast.error("All detected lists must have at least one tag");
      return [];
    }
    
    // Function to create all permutations
    function generateAllPermutations(prompt, remainingLists, currentPermutations = []) {
      if (remainingLists.length === 0) {
        // Add the suffix to all final prompts
        return currentPermutations.length > 0 
          ? currentPermutations.map(p => p + promptSuffix) 
          : [prompt + promptSuffix];
      }
      
      const listId = remainingLists[0];
      const listTags = lists[listId];
      const newRemainingLists = remainingLists.slice(1);
      
      // For the first list, initialize permutations
      if (currentPermutations.length === 0) {
        const initialPermutations = listTags.map(tag => 
          prompt.replace(new RegExp(`\\{${listId.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\}`, 'g'), tag)
        );
        return generateAllPermutations(prompt, newRemainingLists, initialPermutations);
      }
      
      // For subsequent lists, create permutations for each existing permutation
      const newPermutations = [];
      currentPermutations.forEach(permutation => {
        listTags.forEach(tag => {
          newPermutations.push(
            permutation.replace(new RegExp(`\\{${listId.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\}`, 'g'), tag)
          );
        });
      });
      
      return generateAllPermutations(prompt, newRemainingLists, newPermutations);
    }
    
    const prompts = generateAllPermutations(basePrompt, [...detectedLists]);
    setGeneratedPrompts(prompts);
    return prompts;
  }, [basePrompt, detectedLists, lists, promptSuffix]);

  // Handle submit button click
  const handleSubmit = () => {
    const prompts = generatePermutations();
    if (prompts && prompts.length > 0 && onGenerateImages) {
      onGenerateImages(prompts);
    }
  };

  // Get colorful Figma-inspired badge styles
  const getTagColor = (listId, index) => {
    const colors = [
      "bg-[#A259FF] text-white", // Purple
      "bg-[#F24E1E] text-white", // Red
      "bg-[#1ABCFE] text-white", // Blue
      "bg-[#0ACF83] text-white", // Green
      "bg-[#FF7262] text-white", // Coral
      "bg-[#FF8A00] text-white", // Orange
    ];
    
    // Deterministic color assignment based on listId and index
    const colorIndex = (listId.charCodeAt(0) + index) % colors.length;
    return colors[colorIndex];
  };

  return (
    <div className="space-y-4">
      <div className="space-y-2">
        <div className="flex items-center">
          <Label htmlFor="prompt" className="text-xs">Leietekst</Label>
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Info className="h-3.5 w-3.5 ml-1 text-muted-foreground" />
              </TooltipTrigger>
              <TooltipContent>
              <p className="text-xs max-w-[200px]">
                Bruk {"{person}"}, {"{pose}"} som plasshaldarar. For fleire variantar, 
                bruk {"{person*3}"}-syntaksen for 친 gjenta ein tag 3 gongar.
              </p>
            </TooltipContent>

            </Tooltip>
          </TooltipProvider>
        </div>
        <Textarea
          id="prompt"
          placeholder="Enter prompt with {placeholders} in curly braces"
          value={basePrompt}
          onChange={(e) => setBasePrompt(e.target.value)}
          className="min-h-[80px]"
        />
      </div>

      {detectedLists.length > 0 && (
        <div className="space-y-3">
          {detectedLists.map(listId => (
            <Card key={listId} className="p-3 space-y-2">
              <div className="flex items-center justify-between">
                <span className="text-xs font-medium">{listId} ({lists[listId]?.length || 0})</span>
              </div>
              
              <div className="flex flex-wrap gap-2 min-h-[40px] items-center">
                {lists[listId]?.map((tag, index) => (
                  <div key={index} className="relative">
                    {editingTag.listId === listId && editingTag.index === index ? (
                      <div className="flex items-center">
                        <input
                          ref={editInputRef}
                          type="text"
                          className="h-7 px-2 py-0 text-xs border rounded-full focus:outline-none focus:ring-1 focus:ring-primary w-[120px]"
                          value={editingTag.value}
                          onChange={(e) => setEditingTag({...editingTag, value: e.target.value})}
                          onKeyDown={handleEditKeyPress}
                          onBlur={completeTagEdit}
                        />
                        <Button
                          variant="ghost"
                          size="icon"
                          className="h-5 w-5 ml-1"
                          onClick={completeTagEdit}
                        >
                          <Check className="h-3 w-3" />
                        </Button>
                      </div>
                    ) : (
                      <Badge 
                        className={`px-3 py-1 text-xs rounded-full ${getTagColor(listId, index)} cursor-pointer group`}
                        onClick={() => startEditTag(listId, index, tag)}
                      >
                        <span className="group-hover:underline">{tag}</span>
                        <Button
                          variant="ghost"
                          size="icon"
                          className="h-4 w-4 ml-1 -mr-1 text-white/90 hover:text-white hover:bg-transparent opacity-70 group-hover:opacity-100"
                          onClick={(e) => {
                            e.stopPropagation();
                            removeTag(listId, index);
                          }}
                        >
                          <X className="h-3 w-3" />
                        </Button>
                        <span className="sr-only">Edit</span>
                      </Badge>
                    )}
                  </div>
                ))}
                
                <Badge 
                  className="bg-muted text-muted-foreground hover:bg-muted/80 px-2 py-1 rounded-full cursor-pointer h-6 w-6 flex items-center justify-center"
                  onClick={() => setActiveListId(listId)}
                >
                  <Plus className="h-3 w-3" />
                </Badge>
                
                {activeListId === listId && (
                  <div className="flex items-center">
                    <input
                      autoFocus
                      type="text"
                      className="h-7 px-2 py-0 text-xs border rounded-full focus:outline-none focus:ring-1 focus:ring-primary w-[120px]"
                      placeholder="Add tag or tag*n..."
                      value={newTag}
                      onChange={(e) => setNewTag(e.target.value)}
                      onKeyDown={(e) => {
                        if (e.key === 'Enter') {
                          e.preventDefault();
                          addTag(listId, newTag);
                          setNewTag("");
                        } else if (e.key === 'Escape') {
                          setActiveListId(null);
                          setNewTag("");
                        }
                      }}
                      onBlur={() => {
                        if (newTag.trim()) {
                          addTag(listId, newTag);
                        }
                        setActiveListId(null);
                        setNewTag("");
                      }}
                    />
                  </div>
                )}
              </div>
            </Card>
          ))}
          
          <Button 
            variant="default" 
            size="sm"
            className="w-full justify-start h-8"
            disabled={!detectedLists.every(list => lists[list]?.length > 0)}
            onClick={handleSubmit}
          >
            <span className="mr-auto">
              Generate {generatedPrompts.length || detectedLists.reduce((acc, list) => acc * (lists[list]?.length || 1), 1)} Images
            </span>
          </Button>
        </div>
      )}
    </div>
  );
}
--------------------------------------------------------------------------------
File: components/image-generation.tsx
================================================================================
"use client";

import { useState } from "react";
import { PromptGenerator } from "./prompt-generator";
import { Button } from "@/components/ui/button";
import { Loader2, Image as ImageIcon } from "lucide-react";
import Image from "next/image";
import { Card } from "@/components/ui/card";
import { toast } from "sonner";

export function ImageGeneration({ 
  onImagesGenerated, 
  onSubmit, 
  forcedAspectRatio = "1:1",
  useMostPermissiveSafetyLevel = true,
  useImagen3 = true
}) {
  const [generatingImages, setGeneratingImages] = useState(false);
  const [generatedImages, setGeneratedImages] = useState([]);
  const [progress, setProgress] = useState({ current: 0, total: 0 });
  
  // Comprehensive negative prompt for clean isolated subjects
  const negativePrompt = "blurry, distorted, low quality, low resolution, deformed, disfigured, " +
    "out of frame, cropped, missing limbs, partial body, head only, close-up, " +
    "watermark, signature, text, environment, props, objects, " + 
    "cluttered background, distracting details, multiple people, group, crowd, trees, outdoors, " +
    "furniture, buildings, landscape, room interior";

  // Function to generate images from prompts
  const generateImages = async (prompts) => {
    if (prompts.length === 0) return;
    
    setGeneratingImages(true);
    setProgress({ current: 0, total: prompts.length });
    const images = [];
    const pendingSubmissions = [];

    try {
      // Process prompts sequentially
      for (let i = 0; i < prompts.length; i++) {
        const prompt = prompts[i];
        setProgress({ current: i + 1, total: prompts.length });
        
        // Create a pending submission card
        const pendingId = `pending-${Date.now()}-${i}`;
        const pendingSubmission = {
          id: pendingId,
          status: "starting",
          input: { image: "" },
          created_at: new Date().toISOString(),
          prompt: prompt.replace(/, full standing body, head to toe view, studio lighting, set stark against a solid white background/g, "")
        };
        pendingSubmissions.push(pendingSubmission);
        
        // Call the API to generate an image
        const response = await fetch("/api/generate-image", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ 
            prompt, 
            aspect_ratio: forcedAspectRatio,
            negative_prompt: negativePrompt,
            safety_filter_level: useMostPermissiveSafetyLevel ? "block_only_high" : "block_medium_and_above",
            use_imagen3: useImagen3
          }),
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error || errorData.details || "Image generation failed");
        }

        const data = await response.json();
        
        if (data.imageUrl) {
          images.push({
            url: data.imageUrl,
            prompt,
            pendingId
          });
        }
      }

      // Update pending submissions with the generated images
      for (let i = 0; i < images.length; i++) {
        const image = images[i];
        const pendingSubmission = pendingSubmissions.find(p => p.id === image.pendingId);
        if (pendingSubmission) {
          pendingSubmission.input.image = image.url;
        }
      }

      // Notify parent about new submissions
      if (onSubmit && pendingSubmissions.length > 0) {
        onSubmit(pendingSubmissions);
      }

      setGeneratedImages(images);
      
      if (onImagesGenerated && images.length > 0) {
        // Pass the generated image URLs to the parent component
        onImagesGenerated(images.map(img => img.url));
      }
      
      toast.success(`Generated ${images.length} images`);
    } catch (error) {
      console.error("Error generating images:", error);
      toast.error("Error generating images: " + (error.message || "Unknown error"));
    } finally {
      setGeneratingImages(false);
    }
  };

  return (
    <div className="space-y-4">
      <PromptGenerator onGenerateImages={generateImages} />
      
      {generatingImages && (
        <div className="flex items-center justify-center p-4 border rounded-md">
          <div className="text-center">
            <Loader2 className="h-8 w-8 animate-spin mx-auto mb-2" />
            <p className="text-sm">
              Generating image {progress.current} of {progress.total}...
            </p>
          </div>
        </div>
      )}
      
      {generatedImages.length > 0 && !generatingImages && (
        <div className="space-y-2">
          <div className="grid grid-cols-2 md:grid-cols-3 gap-3">
            {generatedImages.map((image, index) => (
              <Card key={index} className="overflow-hidden">
                <div className="relative aspect-square">
                  <Image
                    src={image.url}
                    alt={`Generated image ${index + 1}`}
                    fill
                    className="object-cover"
                    unoptimized
                  />
                </div>
                <div className="p-2">
                  <div className="flex justify-end">
                    <Button 
                      variant="outline" 
                      size="sm" 
                      className="h-7 text-xs"
                      onClick={() => {
                        if (onImagesGenerated) {
                          onImagesGenerated([image.url]);
                        }
                      }}
                    >
                      <span className="mr-auto flex items-center">
                        <ImageIcon className="h-3 w-3 mr-1" /> Use
                      </span>
                    </Button>
                  </div>
                </div>
              </Card>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}
--------------------------------------------------------------------------------
File: components/mobile-controls.tsx
================================================================================
"use client"

import type React from "react"
import { useState } from "react"
import { ChevronUp, ChevronDown } from "lucide-react"
import { cn } from "@/lib/utils"

interface MobileControlsProps {
  children: React.ReactNode
  onGalleryClick: () => void
}

export function MobileControls({ children, onGalleryClick }: MobileControlsProps) {
  const [isExpanded, setIsExpanded] = useState(false)

  return (
    <div
      className={cn(
        "fixed bottom-0 left-0 right-0 bg-background/80 backdrop-blur-lg border-t transition-transform duration-300 ease-in-out z-50",
        !isExpanded && "translate-y-[calc(100%-2.5rem)]"
      )}
    >
      <div className="flex items-center justify-between px-4 py-2 border-b">
        <button
          onClick={() => setIsExpanded(!isExpanded)}
          className="flex items-center gap-1 text-xs text-muted-foreground"
        >
          {isExpanded ? <ChevronDown className="w-3 h-3" /> : <ChevronUp className="w-3 h-3" />} Controls
        </button>
        <button
          onClick={onGalleryClick}
          className="text-xs border border-black rounded px-2 py-1 text-muted-foreground"
        >
          Gallery
        </button>
      </div>
      <div className="max-h-[70vh] overflow-y-auto p-3">{children}</div>
    </div>
  )
}
  
--------------------------------------------------------------------------------
File: components/predictions-grid.tsx
================================================================================
// components/predictions-grid.tsx
"use client";

import { useEffect, useState, useRef, useCallback } from "react";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { CheckCircle2, Circle, Save, AlertCircle, Trash2, Eye, EyeOff, FolderOpen, Plus, Check, Move, Pencil, Download, X } from "lucide-react";
import Image from "next/image";
import type { Prediction, SavedModel } from "@/app/actions";
import { Project, ProjectModel } from "@/types/database";
import { getSavedModels, getProjects, getProjectModels, deleteProject, deleteProjectModel, moveModelsToProject, renameModels } from "@/app/actions";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { toast } from "sonner";
import { Button } from "@/components/ui/button";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import JSZip from "jszip";
import { saveAs } from "file-saver";

type PendingSubmission = {
  id: string;
  status: string;
  input: { image: string };
  created_at: string;
  prompt: string;
};

type PredictionsGridProps = {
  onSelectModel: (meshUrl: string, inputImage?: string, resolution?: number) => void;
  showAll?: boolean;
  pendingSubmissions?: PendingSubmission[];
  currentProjectId?: string | null;
  onCreateProject?: () => void;
};

type PredictionsState = {
  predictions: Prediction[];
  savedModels: SavedModel[];
  pendingSubmissions: PendingSubmission[];
  projects: Project[];
  projectModels: Record<string, ProjectModel[]>;
  loading: boolean;
  activeTab: "replicate" | "stored" | "projects";
  error: string | null;
  consecutiveErrors: number;
  showInProgress: boolean;
  selectedProjectId: string | null;
};

export const PredictionsGrid = ({ 
  onSelectModel, 
  showAll = false, 
  pendingSubmissions = [],
  currentProjectId,
  onCreateProject
}: PredictionsGridProps) => {
  const [state, setState] = useState<PredictionsState>({
    predictions: [],
    savedModels: [],
    pendingSubmissions: [],
    projects: [],
    projectModels: {},
    loading: true,
    activeTab: currentProjectId ? "projects" : "replicate",
    error: null,
    consecutiveErrors: 0,
    showInProgress: true,
    selectedProjectId: currentProjectId || null,
  });

  const [selectedItems, setSelectedItems] = useState<Set<string>>(new Set());
  const [selectionMode, setSelectionMode] = useState(false);
  const [selectionBox, setSelectionBox] = useState<{startX: number, startY: number, endX: number, endY: number} | null>(null);
  const [isDragging, setIsDragging] = useState(false);
  const gridRef = useRef<HTMLDivElement>(null);
  const itemRefs = useRef<Map<string, DOMRect>>(new Map());
  
  const [moveDialogOpen, setMoveDialogOpen] = useState(false);
  const [renameDialogOpen, setRenameDialogOpen] = useState(false);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [targetProjectId, setTargetProjectId] = useState<string | null>(null);
  const [newNameBase, setNewNameBase] = useState("");

  useEffect(() => {
    if (pendingSubmissions.length > 0) {
      setState(prev => ({
        ...prev,
        pendingSubmissions: [...pendingSubmissions, ...prev.pendingSubmissions]
      }));
    }
  }, [pendingSubmissions]);

  useEffect(() => {
    if (currentProjectId) {
      setState(prev => ({
        ...prev,
        selectedProjectId: currentProjectId,
        activeTab: "projects"
      }));
    }
  }, [currentProjectId]);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === "Shift") setSelectionMode(true);
    };
    
    const handleKeyUp = (e: KeyboardEvent) => {
      if (e.key === "Shift") setSelectionMode(false);
    };
    
    window.addEventListener("keydown", handleKeyDown);
    window.addEventListener("keyup", handleKeyUp);
    
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
    };
  }, []);

  useEffect(() => {
    setSelectedItems(new Set());
  }, [state.activeTab]);

  useEffect(() => {
    let mounted = true;
    let pollInterval: NodeJS.Timeout;

    const fetchData = async () => {
      try {
        if (!mounted) return;

        if (state.activeTab === "replicate") {
          const res = await fetch(`/api/predictions?t=${Date.now()}`, {
            cache: "no-store",
            headers: { "Cache-Control": "no-cache, no-store, must-revalidate" },
          });

          if (!res.ok) throw new Error(`Failed to fetch: ${res.status}`);

          const data = await res.json();

          if (!Array.isArray(data)) {
            throw new Error("Invalid API response format");
          }

          const validPredictions = data.filter((p: any): p is Prediction => {
            try {
              return (
                p &&
                typeof p === "object" &&
                typeof p.id === "string" &&
                typeof p.status === "string" &&
                (!p.error || typeof p.error === "string") &&
                p.input &&
                typeof p.input === "object" &&
                (!p.output || typeof p.output === "object") &&
                typeof p.created_at === "string" &&
                (!p.metrics || typeof p.metrics === "object")
              );
            } catch {
              return false;
            }
          });

          const filteredPredictions = showAll || state.showInProgress
            ? validPredictions
            : validPredictions.filter((p) => p.status === "succeeded");

          const apiIds = validPredictions.map(p => p.id);
          const updatedPendingSubmissions = state.pendingSubmissions.filter(
            ps => !ps.id.includes("pending-") || !apiIds.includes(ps.id)
          );

          if (mounted) {
            setState((prev) => ({
              ...prev,
              predictions: filteredPredictions,
              pendingSubmissions: updatedPendingSubmissions,
              consecutiveErrors: 0,
              error: null,
            }));
          }
        }

        try {
          const models = await getSavedModels();
          if (mounted) {
            setState((prev) => ({
              ...prev,
              savedModels: models,
              loading: false,
            }));
          }
        } catch (err) {
          console.error("Failed to fetch saved models:", err);
          if (mounted) {
            setState((prev) => ({
              ...prev,
              error: "Failed to load saved models",
              loading: false,
            }));
          }
        }

        if (state.activeTab === "projects") {
          try {
            const projects = await getProjects();
            
            if (state.selectedProjectId || projects.length > 0) {
              const projectId = state.selectedProjectId || projects[0]?.id;
              
              if (projectId) {
                const projectModels = await getProjectModels(projectId);
                
                if (mounted) {
                  setState((prev) => ({
                    ...prev,
                    projects,
                    projectModels: {
                      ...prev.projectModels,
                      [projectId]: projectModels
                    },
                    selectedProjectId: projectId,
                    loading: false,
                  }));
                }
              } else {
                if (mounted) {
                  setState((prev) => ({
                    ...prev,
                    projects,
                    loading: false,
                  }));
                }
              }
            } else {
              if (mounted) {
                setState((prev) => ({
                  ...prev,
                  projects,
                  loading: false,
                }));
              }
            }
          } catch (err) {
            console.error("Failed to fetch projects:", err);
            if (mounted) {
              setState((prev) => ({
                ...prev,
                error: "Failed to load projects",
                loading: false,
              }));
            }
          }
        }
      } catch (err) {
        console.error("Fetch error:", err);
        if (mounted) {
          setState((prev) => {
            const newErrors = prev.consecutiveErrors + 1;
            if (newErrors >= 3) {
              toast.error("Failed to load predictions");
            }
            return {
              ...prev,
              error: "Failed to load predictions",
              consecutiveErrors: newErrors,
              loading: false,
            };
          });
        }
      }
    };

    fetchData();

    if (state.activeTab === "replicate") {
      const interval = Math.min(5000 * Math.pow(2, state.consecutiveErrors), 30000);
      pollInterval = setInterval(fetchData, interval);
    }

    return () => {
      mounted = false;
      if (pollInterval) clearInterval(pollInterval);
    };
  }, [state.activeTab, state.consecutiveErrors, state.showInProgress, showAll, state.pendingSubmissions, state.selectedProjectId]);

  const inProgressCount = state.predictions.filter(p => 
    ["starting", "processing"].includes(p.status)
  ).length + state.pendingSubmissions.length;

  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    if (!selectionMode || !gridRef.current) return;
    
    const rect = gridRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    setSelectionBox({ startX: x, startY: y, endX: x, endY: y });
    setIsDragging(true);
  }, [selectionMode]);
  
  const handleMouseMove = useCallback((e: React.MouseEvent) => {
    if (!isDragging || !selectionBox || !gridRef.current) return;
    
    const rect = gridRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    setSelectionBox(prev => ({
      ...prev!,
      endX: x,
      endY: y
    }));
  }, [isDragging, selectionBox]);
  
  const handleMouseUp = useCallback(() => {
    if (!isDragging || !selectionBox || !gridRef.current) return;
    
    const left = Math.min(selectionBox.startX, selectionBox.endX);
    const right = Math.max(selectionBox.startX, selectionBox.endX);
    const top = Math.min(selectionBox.startY, selectionBox.endY);
    const bottom = Math.max(selectionBox.startY, selectionBox.endY);
    
    const newSelectedItems = new Set(selectedItems);
    
    itemRefs.current.forEach((itemRect, id) => {
      const intersects = !(
        itemRect.right < left ||
        itemRect.left > right ||
        itemRect.bottom < top ||
        itemRect.top > bottom
      );
      
      if (intersects) {
        newSelectedItems.add(id);
      }
    });
    
    setSelectedItems(newSelectedItems);
    setIsDragging(false);
    setSelectionBox(null);
  }, [isDragging, selectionBox, selectedItems]);

  const registerItemRef = useCallback((id: string, element: HTMLElement | null) => {
    if (element) {
      const rect = element.getBoundingClientRect();
      itemRefs.current.set(id, rect);
    }
  }, []);

  const toggleItemSelection = useCallback((id: string, event: React.MouseEvent) => {
    if (!selectionMode) return;
    
    event.stopPropagation();
    event.preventDefault();
    
    setSelectedItems(prev => {
      const newSet = new Set(prev);
      if (newSet.has(id)) {
        newSet.delete(id);
      } else {
        newSet.add(id);
      }
      return newSet;
    });
  }, [selectionMode]);

  const clearSelection = useCallback(() => {
    setSelectedItems(new Set());
  }, []);

  const handleDownloadZip = async () => {
    if (selectedItems.size === 0) return;
    
    try {
      toast.loading("Preparing ZIP file...");
      
      let modelUrls: string[] = [];
      
      if (state.activeTab === "replicate") {
        modelUrls = state.predictions
          .filter(p => selectedItems.has(p.id) && p.status === "succeeded" && p.output?.mesh)
          .map(p => p.output!.mesh!);
      } else if (state.activeTab === "stored") {
        modelUrls = state.savedModels
          .filter(m => selectedItems.has(m.id))
          .map(m => m.url);
      } else if (state.activeTab === "projects" && state.selectedProjectId) {
        const selectedProjectModels = state.projectModels[state.selectedProjectId] || [];
        modelUrls = selectedProjectModels
          .filter(m => selectedItems.has(m.id))
          .map(m => m.model_url);
      }
      
      if (modelUrls.length === 0) {
        toast.error("No valid models selected for download");
        return;
      }
      
      const zip = new JSZip();
      
      for (let i = 0; i < modelUrls.length; i++) {
        try {
          const url = modelUrls[i];
          const response = await fetch(url);
          if (!response.ok) throw new Error(`Failed to fetch ${url}`);
          
          const blob = await response.blob();
          const filename = `model-${i + 1}.glb`;
          zip.file(filename, blob);
        } catch (error) {
          console.error(`Error adding file to ZIP:`, error);
        }
      }
      
      const zipBlob = await zip.generateAsync({ type: "blob" });
      saveAs(zipBlob, "archifigure-models.zip");
      
      toast.success(`${modelUrls.length} models downloaded as ZIP`);
    } catch (error) {
      console.error("ZIP download error:", error);
      toast.error("Failed to create ZIP file");
    }
  };

  const handleMoveModels = async () => {
    if (selectedItems.size === 0 || !targetProjectId) return;
    setMoveDialogOpen(false);
    
    try {
      toast.loading(`Moving ${selectedItems.size} models...`);
      
      if (state.activeTab !== "projects" || !state.selectedProjectId) {
        toast.error("Only project models can be moved");
        return;
      }
      
      const selectedProjectModels = state.projectModels[state.selectedProjectId] || [];
      const modelIds = selectedProjectModels
        .filter(m => selectedItems.has(m.id))
        .map(m => m.id);
      
      if (modelIds.length === 0) {
        toast.error("No valid models selected for moving");
        return;
      }
      
      const success = await moveModelsToProject(modelIds, targetProjectId);
      
      if (success) {
        toast.success(`${modelIds.length} models moved successfully`);
        clearSelection();
        
        const projectModels = await getProjectModels(state.selectedProjectId);
        setState(prev => ({
          ...prev,
          projectModels: {
            ...prev.projectModels,
            [state.selectedProjectId]: projectModels
          }
        }));
      } else {
        toast.error("Failed to move models");
      }
    } catch (error) {
      console.error("Move error:", error);
      toast.error("Failed to move models");
    }
  };

  const handleRenameModels = async () => {
    if (selectedItems.size === 0 || !newNameBase.trim()) return;
    setRenameDialogOpen(false);
    
    try {
      toast.loading(`Renaming ${selectedItems.size} models...`);
      
      if (state.activeTab !== "projects" || !state.selectedProjectId) {
        toast.error("Only project models can be renamed");
        return;
      }
      
      const selectedProjectModels = state.projectModels[state.selectedProjectId] || [];
      const modelIds = selectedProjectModels
        .filter(m => selectedItems.has(m.id))
        .map(m => m.id);
      
      if (modelIds.length === 0) {
        toast.error("No valid models selected for renaming");
        return;
      }
      
      const success = await renameModels(modelIds, newNameBase);
      
      if (success) {
        toast.success(`${modelIds.length} models renamed successfully`);
        clearSelection();
        
        const projectModels = await getProjectModels(state.selectedProjectId);
        setState(prev => ({
          ...prev,
          projectModels: {
            ...prev.projectModels,
            [state.selectedProjectId]: projectModels
          }
        }));
      } else {
        toast.error("Failed to rename models");
      }
    } catch (error) {
      console.error("Rename error:", error);
      toast.error("Failed to rename models");
    }
  };

  const handleDeleteModels = async () => {
    if (selectedItems.size === 0) return;
    setDeleteDialogOpen(false);
    
    try {
      toast.loading(`Deleting ${selectedItems.size} models...`);
      
      if (state.activeTab === "stored") {
        const modelIds = state.savedModels
          .filter(m => selectedItems.has(m.id))
          .map(m => m.id);
        
        if (modelIds.length === 0) {
          toast.error("No valid models selected for deletion");
          return;
        }
        
        let success = true;
        for (const id of modelIds) {
          try {
            await fetch("/api/delete-model", {
              method: "DELETE",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ id }),
            });
          } catch (error) {
            console.error(`Error deleting model ${id}:`, error);
            success = false;
          }
        }
        
        if (success) {
          toast.success(`${modelIds.length} models deleted successfully`);
          clearSelection();
          
          setState(prev => ({
            ...prev,
            savedModels: prev.savedModels.filter(m => !selectedItems.has(m.id))
          }));
        } else {
          toast.error("Failed to delete some models");
        }
      } else if (state.activeTab === "projects" && state.selectedProjectId) {
        const selectedProjectModels = state.projectModels[state.selectedProjectId] || [];
        const modelIds = selectedProjectModels
          .filter(m => selectedItems.has(m.id))
          .map(m => m.id);
        
        if (modelIds.length === 0) {
          toast.error("No valid models selected for deletion");
          return;
        }
        
        let success = true;
        for (const id of modelIds) {
          try {
            await deleteProjectModel(id);
          } catch (error) {
            console.error(`Error deleting model ${id}:`, error);
            success = false;
          }
        }
        
        if (success) {
          toast.success(`${modelIds.length} models deleted successfully`);
          clearSelection();
          
          const projectModels = await getProjectModels(state.selectedProjectId);
          setState(prev => ({
            ...prev,
            projectModels: {
              ...prev.projectModels,
              [state.selectedProjectId]: projectModels
            }
          }));
        } else {
          toast.error("Failed to delete some models");
        }
      }
    } catch (error) {
      console.error("Delete error:", error);
      toast.error("Failed to delete models");
    }
  };

  const loadProjectModels = async (projectId: string) => {
    try {
      setState(prev => ({ ...prev, loading: true, selectedProjectId: projectId }));
      
      const projectModels = await getProjectModels(projectId);
      
      setState(prev => ({
        ...prev,
        projectModels: {
          ...prev.projectModels,
          [projectId]: projectModels
        },
        loading: false
      }));
    } catch (error) {
      console.error("Error loading project models:", error);
      toast.error("Failed to load project models");
      setState(prev => ({ ...prev, loading: false }));
    }
  };

  const handleCreateProject = () => {
    if (onCreateProject) {
      onCreateProject();
    }
  };

  const renderPendingSubmissionCard = (submission: PendingSubmission) => {
    return (
      <Card
        key={submission.id}
        className="w-full h-full aspect-square opacity-75"
      >
        <div className="relative aspect-square bg-muted/60">
          {submission.input.image ? (
            <Image
              src={submission.input.image}
              alt="Pending submission"
              fill
              className="object-cover rounded-t-lg opacity-50"
              unoptimized
            />
          ) : (
            <div className="absolute inset-0 flex items-center justify-center">
              <span className="text-sm text-muted-foreground">Pending</span>
            </div>
          )}
          <div className="absolute inset-0 flex items-center justify-center">
            <div className="h-10 w-10 rounded-full border-4 border-primary border-t-transparent animate-spin" />
          </div>
        </div>
        <div className="p-2 text-xs text-muted-foreground flex items-center justify-between">
          <span>Pending</span>
          <span>Processing...</span>
        </div>
      </Card>
    );
  };

  const renderPredictionCard = (prediction: Prediction) => {
    if (!prediction?.input?.image) return null;

    const isProcessing = ["starting", "processing"].includes(prediction.status);
    const hasError = !!prediction.error;
    const isClickable = prediction.status === "succeeded" && prediction.output?.mesh;

    return (
      <Card
        key={prediction.id}
        ref={element => registerItemRef(prediction.id, element)}
        className={`w-full h-full aspect-square ${
          selectedItems.has(prediction.id) ? "ring-2 ring-primary" : ""
        } ${
          isClickable ? "cursor-pointer transition-transform hover:scale-105 active:scale-95" : "opacity-75"
        }`}
        onClick={(e) => {
          if (selectionMode) {
            toggleItemSelection(prediction.id, e);
          } else if (isClickable && prediction.output?.mesh) {
            onSelectModel(prediction.output.mesh, prediction.input.image, prediction.input.octree_resolution);
          }
        }}
      >
        <div className="relative aspect-square">
          <Image
            src={prediction.input.image || "/placeholder.svg"}
            alt="Model preview"
            fill
            className="object-cover rounded-t-lg"
            unoptimized
          />
          <div className="absolute top-2 right-2 flex gap-1">
            {selectedItems.has(prediction.id) && (
              <Badge variant="default" className="h-5 w-5 p-0 flex items-center justify-center bg-primary">
                <Check className="w-3 h-3" />
              </Badge>
            )}
            <Badge
              variant={hasError ? "destructive" : prediction.status === "succeeded" ? "default" : "secondary"}
              className="h-5 w-5 p-0 flex items-center justify-center"
            >
              {hasError ? (
                <AlertCircle className="w-3 h-3" />
              ) : prediction.status === "succeeded" ? (
                <CheckCircle2 className="w-3 h-3" />
              ) : (
                <Circle className={`w-3 h-3 ${isProcessing ? "animate-pulse" : ""}`} />
              )}
            </Badge>
          </div>
        </div>
        <div className="p-2 text-xs text-muted-foreground flex items-center justify-between">
          <span>{prediction.input.octree_resolution || "256"}</span>
          <span>
            {hasError
              ? "Failed"
              : isProcessing
              ? "Processing..."
              : prediction.metrics?.predict_time
              ? `${prediction.metrics.predict_time.toFixed(0)}s`
              : "Ready"}
          </span>
        </div>
      </Card>
    );
  };

  const renderSavedModelCard = (model: SavedModel) => (
    <Card
      key={model.id}
      ref={element => registerItemRef(model.id, element)}
      className={`w-full h-full aspect-square cursor-pointer transition-transform hover:scale-105 active:scale-95 relative
        ${selectedItems.has(model.id) ? "ring-2 ring-primary" : ""}`}
      onClick={(e) => {
        if (selectionMode) {
          toggleItemSelection(model.id, e);
        } else {
          onSelectModel(model.url, model.input_image, model.resolution);
        }
      }}
    >
      <div className="relative aspect-square">
        <Image
          src={model.thumbnail_url || "/placeholder.svg"}
          alt="Saved model"
          fill
          className="object-cover rounded-t-lg"
          unoptimized
        />
        <div className="absolute top-2 right-2 flex gap-1">
          {selectedItems.has(model.id) && (
            <Badge variant="default" className="h-5 w-5 p-0 flex items-center justify-center bg-primary">
              <Check className="w-3 h-3" />
            </Badge>
          )}
          <Badge variant="default" className="h-5 w-5 p-0 flex items-center justify-center">
            <Save className="w-3 h-3" />
          </Badge>
          <Badge
            variant="destructive"
            className="h-5 w-5 p-0 flex items-center justify-center cursor-pointer"
            onClick={(e) => {
              e.stopPropagation();
              if (selectionMode) return;
              
              fetch("/api/delete-model", {
                method: "DELETE",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ id: model.id }),
              }).then(res => {
                if (res.ok) {
                  setState((prev) => ({
                    ...prev,
                    savedModels: prev.savedModels.filter((m) => m.id !== model.id),
                  }));
                  toast.success("Model deleted successfully");
                } else {
                  toast.error("Failed to delete model");
                }
              }).catch(err => {
                toast.error("Error deleting model");
              });
            }}
          >
            <Trash2 className="w-3 h-3" />
          </Badge>
        </div>
      </div>
      <div className="p-2 text-xs text-muted-foreground flex items-center justify-between">
        <span>{model.resolution}</span>
        <span>Saved</span>
      </div>
    </Card>
  );

  const renderProjectModelCard = (model: ProjectModel) => (
    <Card
      key={model.id}
      ref={element => registerItemRef(model.id, element)}
      className={`w-full h-full aspect-square cursor-pointer transition-transform hover:scale-105 active:scale-95 relative
        ${selectedItems.has(model.id) ? "ring-2 ring-primary" : ""}`}
      onClick={(e) => {
        if (selectionMode) {
          toggleItemSelection(model.id, e);
        } else {
          onSelectModel(model.model_url, model.input_image, model.resolution);
        }
      }}
    >
      <div className="relative aspect-square">
        <Image
          src={model.thumbnail_url || "/placeholder.svg"}
          alt="Project model"
          fill
          className="object-cover rounded-t-lg"
          unoptimized
        />
        <div className="absolute top-2 right-2 flex gap-1">
          {selectedItems.has(model.id) && (
            <Badge variant="default" className="h-5 w-5 p-0 flex items-center justify-center bg-primary">
              <Check className="w-3 h-3" />
            </Badge>
          )}
          <Badge variant="default" className="h-5 w-5 p-0 flex items-center justify-center">
            <FolderOpen className="w-3 h-3" />
          </Badge>
          <Badge
            variant="destructive"
            className="h-5 w-5 p-0 flex items-center justify-center cursor-pointer"
            onClick={async (e) => {
              e.stopPropagation();
              if (selectionMode) return;
              
              try {
                const success = await deleteProjectModel(model.id);
                if (success) {
                  setState((prev) => {
                    const projectModels = prev.projectModels[model.project_id] || [];
                    return {
                      ...prev,
                      projectModels: {
                        ...prev.projectModels,
                        [model.project_id]: projectModels.filter(m => m.id !== model.id)
                      }
                    };
                  });
                  toast.success("Model deleted successfully");
                } else {
                  toast.error("Failed to delete model");
                }
              } catch (err) {
                toast.error("Error deleting model");
              }
            }}
          >
            <Trash2 className="w-3 h-3" />
          </Badge>
        </div>
      </div>
      <div className="p-2 text-xs text-muted-foreground flex items-center justify-between">
        <span>{model.resolution}</span>
        <span>{model.name || "Project"}</span>
      </div>
    </Card>
  );

  const renderProjectCard = (project: Project) => (
    <Card
      key={project.id}
      className={`w-full h-full aspect-square cursor-pointer transition-transform hover:scale-105 active:scale-95 relative ${
        state.selectedProjectId === project.id ? "ring-2 ring-primary" : ""
      }`}
      onClick={() => loadProjectModels(project.id)}
    >
      <div className="relative aspect-square bg-muted flex items-center justify-center">
        <FolderOpen className="h-12 w-12 text-muted-foreground/50" />
        <div className="absolute top-2 right-2 flex gap-1">
          <Badge
            variant="destructive"
            className="h-5 w-5 p-0 flex items-center justify-center cursor-pointer"
            onClick={async (e) => {
              e.stopPropagation();
              
              if (confirm(`Are you sure you want to delete the project "${project.name}" and all its models?`)) {
                try {
                  const success = await deleteProject(project.id);
                  if (success) {
                    setState((prev) => {
                      const newState = {
                        ...prev,
                        projects: prev.projects.filter(p => p.id !== project.id),
                      };
                      
                      const { [project.id]: _, ...remainingProjectModels } = prev.projectModels;
                      newState.projectModels = remainingProjectModels;
                      
                      if (prev.selectedProjectId === project.id) {
                        newState.selectedProjectId = prev.projects.length > 1 
                          ? prev.projects.find(p => p.id !== project.id)?.id || null
                          : null;
                      }
                      
                      return newState;
                    });
                    toast.success("Project deleted successfully");
                  } else {
                    toast.error("Failed to delete project");
                  }
                } catch (err) {
                  toast.error("Error deleting project");
                }
              }
            }}
          >
            <Trash2 className="w-3 h-3" />
          </Badge>
        </div>
      </div>
      <div className="p-2 text-xs flex flex-col gap-1">
        <div className="font-medium truncate" title={project.name}>
          {project.name}
        </div>
        <div className="text-muted-foreground">
          {new Date(project.created_at).toLocaleDateString()}
        </div>
      </div>
    </Card>
  );

  const renderContent = (contentType: "replicate" | "stored" | "projects") => {
    if (contentType === "projects") {
      if (state.loading && state.projects.length === 0) {
        return (
          <div className="flex items-center justify-center min-h-[200px] text-sm text-muted-foreground">
            Loading projects...
          </div>
        );
      }

      if (!state.loading && state.projects.length === 0) {
        return (
          <div className="flex flex-col items-center justify-center min-h-[200px] gap-4">
            <p className="text-sm text-muted-foreground">No projects yet</p>
            <Button onClick={handleCreateProject} size="sm">
              <Plus className="h-4 w-4 mr-2" /> Create Project
            </Button>
          </div>
        );
      }

      return (
        <div className="space-y-4">
          <div className="flex items-center justify-between px-4">
            <h3 className="text-sm font-medium">Projects</h3>
            <Button onClick={handleCreateProject} size="sm" variant="outline">
              <Plus className="h-4 w-4 mr-2" /> New Project
            </Button>
          </div>
          
          <div 
            ref={gridRef}
            className="grid grid-cols-2 sm:grid-cols-3 gap-3 p-4 relative"
            onMouseDown={handleMouseDown}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseUp}
          >
            {state.projects.map(renderProjectCard)}
            
            {isDragging && selectionBox && (
              <div
                className="absolute bg-primary/20 border border-primary/50 pointer-events-none z-10"
                style={{
                  left: Math.min(selectionBox.startX, selectionBox.endX),
                  top: Math.min(selectionBox.startY, selectionBox.endY),
                  width: Math.abs(selectionBox.endX - selectionBox.startX),
                  height: Math.abs(selectionBox.endY - selectionBox.startY),
                }}
              />
            )}
          </div>
          
          {state.selectedProjectId && (
            <div className="space-y-2 px-4">
              <h3 className="text-sm font-medium">
                {state.projects.find(p => p.id === state.selectedProjectId)?.name || "Project"} Models
              </h3>
              
              {state.loading ? (
                <div className="flex items-center justify-center h-48 text-sm text-muted-foreground">
                  Loading models...
                </div>
              ) : state.projectModels[state.selectedProjectId]?.length > 0 ? (
                <div 
                  ref={gridRef}
                  className="grid grid-cols-2 sm:grid-cols-3 gap-3 p-4 relative"
                  onMouseDown={handleMouseDown}
                  onMouseMove={handleMouseMove}
                  onMouseUp={handleMouseUp}
                  onMouseLeave={handleMouseUp}
                >
                  {state.projectModels[state.selectedProjectId].map(renderProjectModelCard)}
                  
                  {isDragging && selectionBox && (
                    <div
                      className="absolute bg-primary/20 border border-primary/50 pointer-events-none z-10"
                      style={{
                        left: Math.min(selectionBox.startX, selectionBox.endX),
                        top: Math.min(selectionBox.startY, selectionBox.endY),
                        width: Math.abs(selectionBox.endX - selectionBox.startX),
                        height: Math.abs(selectionBox.endY - selectionBox.startY),
                      }}
                    />
                  )}
                </div>
              ) : (
                <div className="flex items-center justify-center h-48 text-sm text-muted-foreground">
                  No models in this project yet
                </div>
              )}
            </div>
          )}
        </div>
      );
    }

    if (state.error && contentType === "replicate") {
      return (
        <div className="flex items-center justify-center min-h-[200px] text-sm text-destructive">
          {state.error}
        </div>
      );
    }

    const items = contentType === "replicate" 
      ? state.predictions 
      : contentType === "stored" 
        ? state.savedModels 
        : [];

    if (state.loading && items.length === 0) {
      return (
        <div className="flex items-center justify-center min-h-[200px] text-sm text-muted-foreground">
          Loading...
        </div>
      );
    }

    if (!state.loading && items.length === 0 && state.pendingSubmissions.length === 0) {
      return (
        <div className="flex items-center justify-center min-h-[200px] text-sm text-muted-foreground">
          {contentType === "stored" ? "No saved models" : "No models found"}
        </div>
      );
    }

    return (
      <div 
        ref={gridRef}
        className="grid grid-cols-2 sm:grid-cols-3 gap-3 p-4 relative"
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
      >
        {contentType === "replicate" && state.pendingSubmissions.map(renderPendingSubmissionCard)}
        
        {items.map(item => {
          if (contentType === "stored") {
            return renderSavedModelCard(item as SavedModel);
          } else {
            return renderPredictionCard(item as Prediction);
          }
        })}
        
        {isDragging && selectionBox && (
          <div
            className="absolute bg-primary/20 border border-primary/50 pointer-events-none z-10"
            style={{
              left: Math.min(selectionBox.startX, selectionBox.endX),
              top: Math.min(selectionBox.startY, selectionBox.endY),
              width: Math.abs(selectionBox.endX - selectionBox.startX),
              height: Math.abs(selectionBox.endY - selectionBox.startY),
            }}
          />
        )}
      </div>
    );
  };

  return (
    <>
      <Tabs
        defaultValue={state.activeTab}
        className="w-full"
        value={state.activeTab}
        onValueChange={(value) =>
          setState((prev) => ({
            ...prev,
            activeTab: value as "replicate" | "stored" | "projects",
            selectedProjectId: value === "projects" ? prev.selectedProjectId || (prev.projects[0]?.id || null) : null
          }))
        }
      >
        <div className="border-b bg-muted/40 px-4">
          <div className="flex items-center justify-between">
            <TabsList className="h-9">
              <TabsTrigger value="replicate" className="text-xs">
                Recent ({state.predictions.length + state.pendingSubmissions.length})
              </TabsTrigger>
              <TabsTrigger value="stored" className="text-xs">
                Stored ({state.savedModels.length})
              </TabsTrigger>
              <TabsTrigger value="projects" className="text-xs">
                Projects ({state.projects.length})
              </TabsTrigger>
            </TabsList>
            
            {state.activeTab === "replicate" && inProgressCount > 0 && (
              <Button
                variant="ghost"
                size="icon"
                className="h-8 w-8"
                onClick={() =>
                  setState((prev) => ({
                    ...prev,
                    showInProgress: !prev.showInProgress,
                  }))
                }
                title={state.showInProgress ? "Hide in-progress models" : "Show in-progress models"}
              >
                {state.showInProgress ? <Eye className="h-4 w-4" /> : <EyeOff className="h-4 w-4" />}
              </Button>
            )}
          </div>
        </div>
        <TabsContent value="replicate" className="mt-0">
          {renderContent("replicate")}
        </TabsContent>
        <TabsContent value="stored" className="mt-0">
          {renderContent("stored")}
        </TabsContent>
        <TabsContent value="projects" className="mt-0">
          {renderContent("projects")}
        </TabsContent>
      </Tabs>
      
      {selectedItems.size > 0 && (
        <div className="fixed bottom-4 left-1/2 transform -translate-x-1/2 z-50 
                      bg-background/95 backdrop-blur-sm border rounded-lg shadow-lg 
                      px-4 py-2 flex items-center space-x-2">
          <span className="text-sm font-medium">{selectedItems.size} selected</span>
          
          <div className="h-4 border-r mx-2"></div>
          
          <Button variant="ghost" size="sm" onClick={handleDownloadZip} title="Download as ZIP">
            <Download className="h-4 w-4" />
          </Button>
          
          {state.activeTab === "projects" && (
            <Button variant="ghost" size="sm" onClick={() => setMoveDialogOpen(true)} title="Move to project">
              <Move className="h-4 w-4" />
            </Button>
          )}
          
          {state.activeTab === "projects" && (
            <Button variant="ghost" size="sm" onClick={() => setRenameDialogOpen(true)} title="Rename">
              <Pencil className="h-4 w-4" />
            </Button>
          )}
          
          <Button variant="ghost" size="sm" onClick={() => setDeleteDialogOpen(true)} title="Delete">
            <Trash2 className="h-4 w-4" />
          </Button>
          
          <div className="h-4 border-r mx-2"></div>
          
          <Button variant="ghost" size="sm" onClick={clearSelection} title="Clear selection">
            <X className="h-4 w-4" />
          </Button>
        </div>
      )}
      
      <Dialog open={moveDialogOpen} onOpenChange={setMoveDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Move {selectedItems.size} models to project</DialogTitle>
            <DialogDescription>
              Select the project where you want to move the selected models.
            </DialogDescription>
          </DialogHeader>
          
          <Select 
            value={targetProjectId || undefined} 
            onValueChange={(value) => setTargetProjectId(value)}
          >
            <SelectTrigger>
              <SelectValue placeholder="Select project" />
            </SelectTrigger>
            <SelectContent>
              {state.projects
                .filter(project => project.id !== state.selectedProjectId)
                .map(project => (
                  <SelectItem key={project.id} value={project.id}>
                    {project.name}
                  </SelectItem>
                ))
              }
            </SelectContent>
          </Select>
          
          <DialogFooter>
            <Button variant="outline" onClick={() => setMoveDialogOpen(false)}>Cancel</Button>
            <Button onClick={handleMoveModels} disabled={!targetProjectId}>
              Move
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
      
      <Dialog open={renameDialogOpen} onOpenChange={setRenameDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Rename {selectedItems.size > 1 ? `${selectedItems.size} models` : "model"}</DialogTitle>
            <DialogDescription>
              {selectedItems.size > 1 
                ? "Enter a new base name. The models will be named with a number suffix."
                : "Enter a new name for the selected model."}
            </DialogDescription>
          </DialogHeader>
          
          <Input 
            value={newNameBase} 
            onChange={(e) => setNewNameBase(e.target.value)} 
            placeholder="New name" 
          />
          
          <DialogFooter>
            <Button variant="outline" onClick={() => setRenameDialogOpen(false)}>Cancel</Button>
            <Button onClick={handleRenameModels} disabled={!newNameBase.trim()}>
              Rename
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
      
      <Dialog open={deleteDialogOpen} onOpenChange={setDeleteDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Delete {selectedItems.size} models?</DialogTitle>
            <DialogDescription>
              This action cannot be undone. The selected models will be permanently deleted.
            </DialogDescription>
          </DialogHeader>
          
          <DialogFooter>
            <Button variant="outline" onClick={() => setDeleteDialogOpen(false)}>Cancel</Button>
            <Button variant="destructive" onClick={handleDeleteModels}>
              Delete
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </>
  );
};
--------------------------------------------------------------------------------
File: components/password-lock.tsx
================================================================================
"use client"

import React, { useState, useEffect } from "react"
import { Send } from "lucide-react"
import { useTheme } from "@/components/theme-provider"

interface PasswordLockProps {
  children: React.ReactNode
}

export default function PasswordLock({ children }: PasswordLockProps) {
  const [password, setPassword] = useState("")
  const [authenticated, setAuthenticated] = useState(false)
  const { theme } = useTheme()
  const isDarkMode = theme === "dark"

  useEffect(() => {
    const auth = localStorage.getItem("passwordAuthenticated")
    if (auth === "true") {
      setAuthenticated(true)
    }
  }, [])

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    if (password === "jegvilha3d") {
      setAuthenticated(true)
      localStorage.setItem("passwordAuthenticated", "true")
    } else {
      alert("Incorrect password")
    }
  }

  if (!authenticated) {
    return (
      <div className="flex min-h-screen items-center justify-center bg-background">
        <form 
          onSubmit={handleSubmit} 
          className="flex items-center gap-2 border rounded p-4 bg-background"
        >
          <input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            placeholder="Skriv inn passord"
            className={`px-4 py-2 border rounded focus:outline-none ${
              isDarkMode 
                ? "bg-slate-800 text-white border-slate-600 placeholder-slate-400" 
                : "bg-white text-black border-black placeholder-gray-500"
            }`}
          />
          <button 
            type="submit" 
            className={`p-2 border rounded ${
              isDarkMode 
                ? "bg-slate-800 border-slate-600 text-white hover:bg-slate-700" 
                : "bg-white border-black text-black hover:bg-gray-100"
            }`}
          >
            <Send className="w-5 h-5" />
          </button>
        </form>
      </div>
    )
  }

  return <>{children}</>
}
--------------------------------------------------------------------------------
File: components/model-viewer.tsx
================================================================================
// components/model-viewer.tsx
"use client"

import { Suspense, useState, useEffect, useRef, useCallback } from "react"
import { Canvas, useThree } from "@react-three/fiber"
import { OrbitControls, Html } from "@react-three/drei"
import { GLTFLoader } from "three-stdlib"
import { Alert, AlertDescription } from "@/components/ui/alert"
import { AlertCircle, Layers, Download, Save, Loader2, Expand, X, FolderPlus } from "lucide-react"
import * as THREE from "three"
import { useTheme } from "@/components/theme-provider"
import { Button } from "@/components/ui/button"
import { saveModelToDatabase, saveModelToProject, getProjects, checkModelExists, createProject } from "@/app/actions"
import { toast } from "sonner"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Project } from "@/types/database"
import { ProjectDialog } from "@/components/project-dialog"

interface LightState {
  position: [number, number, number]
  intensity: number
  temperature: number
}

const INITIAL_LIGHT_STATE: LightState = {
  position: [2, 2, 2],
  intensity: 1,
  temperature: 6500,
}

function ModelLoader({
  url,
  onLoad,
  onError,
}: {
  url: string
  onLoad: (scene: THREE.Group) => void
  onError: (error: string) => void
}) {
  const [retryCount, setRetryCount] = useState(0)
  const [model, setModel] = useState<THREE.Group | null>(null)
  const [modelError, setModelError] = useState<string | null>(null)
  const maxRetries = 3

  useEffect(() => {
    let canceled = false
    const loader = new GLTFLoader()
    loader.load(
      url,
      (gltf) => {
        if (!canceled) {
          setModel(gltf.scene)
          onLoad(gltf.scene)
        }
      },
      undefined,
      (err) => {
        if (!canceled) {
          if (retryCount < maxRetries) {
            const timer = setTimeout(() => setRetryCount((prev) => prev + 1), 1000 * retryCount)
            return () => clearTimeout(timer)
          } else {
            const message = err instanceof Error ? err.message : "Failed to load model"
            setModelError(message)
            onError(message)
          }
        }
      }
    )
    return () => {
      canceled = true
    }
  }, [url, retryCount, onLoad, onError, maxRetries])

  if (modelError) {
    return (
      <Html center>
        <div className="flex flex-col items-center gap-2">
          <Loader2 className="h-6 w-6 text-muted-foreground" />
          <div className="text-sm text-muted-foreground">{modelError}</div>
        </div>
      </Html>
    )
  }

  if (!model) {
    return (
      <Html center>
        <div className="flex flex-col items-center gap-2">
          <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
          <div className="text-sm text-muted-foreground">
            {retryCount < maxRetries
              ? `Loading model${retryCount > 0 ? ` (Attempt ${retryCount + 1})` : ""}`
              : "Failed to load model"}
          </div>
        </div>
      </Html>
    )
  }
  return null
}

function ModelContent({
  url,
  onError,
}: {
  url: string
  onError: (error: string) => void
}) {
  const [model, setModel] = useState<THREE.Group | null>(null)
  const materials = useRef(new Map<THREE.Mesh, THREE.Material | THREE.Material[]>())
  const matteMaterial = useRef(
    new THREE.MeshStandardMaterial({
      color: 0xffffff, 
      roughness: 0.8,  
      metalness: 0.0,
    })
  )
  const { scene: threeScene } = useThree()

  const handleModelLoad = useCallback(
    (loadedScene: THREE.Group) => {
      try {
        loadedScene.traverse((obj) => {
          if (obj instanceof THREE.Mesh) {
            materials.current.set(obj, obj.material)
            obj.material = matteMaterial.current
            obj.castShadow = true
            obj.receiveShadow = true
          }
        })
        // Snap model to ground by offsetting its position based on its bounding box
        const box = new THREE.Box3().setFromObject(loadedScene)
        const offsetY = -box.min.y
        loadedScene.position.y += offsetY

        setModel(loadedScene)
      } catch (err) {
        console.error("Model setup error:", err)
        onError("Failed to setup model materials")
      }
    },
    [onError]
  )

  useEffect(() => {
    return () => {
      if (model) {
        model.traverse((obj) => {
          if (obj instanceof THREE.Mesh) {
            if (obj.geometry) obj.geometry.dispose()
            const material = materials.current.get(obj)
            if (Array.isArray(material)) material.forEach((m) => m.dispose())
            else if (material) material.dispose()
          }
        })
        setModel(null)
      }
    }
  }, [url, model])

  const toggleTextures = useCallback(() => {
    if (!model) return
    model.traverse((obj) => {
      if (obj instanceof THREE.Mesh) {
        obj.material =
          obj.material === matteMaterial.current
            ? materials.current.get(obj) || obj.material
            : matteMaterial.current
      }
    })
  }, [model])

  useEffect(() => {
    if (threeScene) {
      threeScene.userData.toggleTextures = toggleTextures
    }
  }, [threeScene, toggleTextures])

  return (
    <>
      {model ? (
        <primitive object={model} scale={1} />
      ) : (
        <ModelLoader url={url} onLoad={handleModelLoad} onError={onError} />
      )}
      <MovableLight />
      {/* Ground plane to receive shadows */}
      <mesh rotation={[-Math.PI / 2, 0, 0]} receiveShadow>
        <planeGeometry args={[100, 100]} />
        <shadowMaterial transparent opacity={0.4} />
      </mesh>
      <OrbitControls
        makeDefault
        minDistance={2}
        maxDistance={10}
        onChange={(e) => {
          if (e && threeScene) {
            threeScene.userData.controls = e.target
          }
        }}
      />
    </>
  )
}

function MovableLight() {
  const [lightState, setLightState] = useState<LightState>(INITIAL_LIGHT_STATE)
  const isDragging = useRef(false)
  const isAdjusting = useRef(false)
  const prevPos = useRef({ x: 0, y: 0 })
  const { gl, scene } = useThree()
  const { theme } = useTheme()

  useEffect(() => {
    const handleMouseDown = (e: MouseEvent) => {
      if (!e.shiftKey) return
      e.preventDefault()
      if (e.altKey) {
        isAdjusting.current = true
      } else {
        isDragging.current = true
      }
      prevPos.current = { x: e.clientX, y: e.clientY }
      if (scene.userData.controls) scene.userData.controls.enabled = false
    }
    const handleMouseMove = (e: MouseEvent) => {
      if (!isDragging.current && !isAdjusting.current) return
      const dx = e.clientX - prevPos.current.x
      const dy = e.clientY - prevPos.current.y
      const scaledDx = dx * 0.05
      const scaledDy = dy * 0.05
      setLightState((prev) => {
        if (isAdjusting.current) {
          const newTemp = Math.max(2000, Math.min(10000, prev.temperature + scaledDx * 100))
          const newInt = Math.max(0, Math.min(6, prev.intensity - scaledDy))
          return { ...prev, intensity: newInt, temperature: newTemp }
        } else {
          return {
            ...prev,
            position: [
              prev.position[0] + scaledDx,
              prev.position[1] - scaledDy,
              prev.position[2],
            ],
          }
        }
      })
      prevPos.current = { x: e.clientX, y: e.clientY }
    }
    const handleMouseUp = () => {
      isDragging.current = false
      isAdjusting.current = false
      if (scene.userData.controls) scene.userData.controls.enabled = true
    }
    gl.domElement.addEventListener("mousedown", handleMouseDown)
    window.addEventListener("mousemove", handleMouseMove)
    window.addEventListener("mouseup", handleMouseUp)
    return () => {
      gl.domElement.removeEventListener("mousedown", handleMouseDown)
      window.removeEventListener("mousemove", handleMouseMove)
      window.removeEventListener("mouseup", handleMouseUp)
    }
  }, [gl, scene])

  const color = tempToColor(lightState.temperature)
  return (
    <>
      <directionalLight
        position={lightState.position}
        intensity={lightState.intensity}
        color={color}
        castShadow
      />
      <group position={lightState.position}>
        <mesh>
          <sphereGeometry args={[0.2, 16, 16]} />
          <meshBasicMaterial color={color} />
        </mesh>
        <line>
          <bufferGeometry>
            <float32BufferAttribute
              attach="attributes-position"
              array={new Float32Array([
                0, 0, 0,
                -lightState.position[0],
                -lightState.position[1],
                -lightState.position[2],
              ])}
              itemSize={3}
            />
          </bufferGeometry>
          <lineBasicMaterial color={theme === "dark" ? "#fff" : "#000"} />
        </line>
        <Html position={[0.3, 0.3, 0]} center>
          <div className="px-2 py-1 text-[10px] bg-background/80 backdrop-blur-sm rounded border">
            {lightState.intensity.toFixed(1)}x  {(lightState.temperature / 1000).toFixed(1)}K
          </div>
        </Html>
      </group>
    </>
  )
}

export function ModelViewer({
  url,
  inputImage,
  resolution,
  currentProjectId,
  onProjectSelect,
}: {
  url: string
  inputImage?: string
  resolution?: number
  currentProjectId?: string | null
  onProjectSelect?: (projectId: string) => void
}) {
  const { theme } = useTheme()
  const [state, setState] = useState({
    error: null as string | null,
    saving: false,
    saveSuccess: false,
  })
  const [projects, setProjects] = useState<Project[]>([])
  const [selectedProjectId, setSelectedProjectId] = useState<string | null>(null)
  const [isMobile, setIsMobile] = useState(false)
  const [isFullscreen, setIsFullscreen] = useState(false)
  const [projectDialogOpen, setProjectDialogOpen] = useState(false)
  
  // Check if viewing on mobile
  useEffect(() => {
    const checkMobile = () => {
      setIsMobile(window.innerWidth < 768)
    }
    
    checkMobile()
    window.addEventListener('resize', checkMobile)
    
    return () => {
      window.removeEventListener('resize', checkMobile)
    }
  }, [])
  
  // Load projects on mount
  useEffect(() => {
    const fetchProjects = async () => {
      try {
        const projectsList = await getProjects();
        setProjects(projectsList);
      } catch (error) {
        console.error("Error fetching projects:", error);
      }
    };
    
    fetchProjects();
  }, []);

  const handleError = useCallback((error: string) => {
    setState((prev) => ({ ...prev, error }))
    toast.error(error)
  }, [])

  const bg = theme === "dark" ? "#000" : "#fff"

  const handleToggleTextures = () => {
    const canvas = document.querySelector("canvas") as any
    canvas?.__r3f?.scene?.userData.toggleTextures?.()
  }

  const handleProjectCreated = async (projectId: string, projectName: string) => {
    setSelectedProjectId(projectId)
    setProjects(prev => [{ 
      id: projectId, 
      name: projectName, 
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    }, ...prev])
    toast.success(`Project "${projectName}" created`)
    
    // Update the parent component if callback provided
    if (onProjectSelect) {
      onProjectSelect(projectId)
    }
  }

  const handleSaveModel = async () => {
    if (!url || !inputImage || !resolution) return;
    
    setState((prev) => ({ ...prev, saving: true, error: null }));
    
    try {
      // Check if model already exists in database or project
      const existsResult = await checkModelExists(url, selectedProjectId || null);
      
      if (existsResult.exists) {
        toast.info("This model is already saved");
        setState((prev) => ({ 
          ...prev, 
          saving: false,
          saveSuccess: true 
        }));
        return;
      }
      
      if (selectedProjectId) {
        // Save to project
        const result = await saveModelToProject(
          selectedProjectId,
          url,
          inputImage, // Using input image as thumbnail
          inputImage,
          resolution,
          `Model ${new Date().toLocaleString()}`
        );
        
        if (result) {
          setState((prev) => ({ ...prev, saveSuccess: true }));
          toast.success("Model saved to project successfully");
          
          // Notify parent component if needed
          if (onProjectSelect && selectedProjectId !== currentProjectId) {
            onProjectSelect(selectedProjectId);
          }
        } else {
          setState((prev) => ({
            ...prev,
            error: "Failed to save model to project",
          }));
          toast.error("Failed to save model to project");
        }
      } else {
        // Save to regular storage
        await saveModelToDatabase(url, inputImage, resolution);
        setState((prev) => ({ ...prev, saveSuccess: true }));
        toast.success("Model saved successfully");
      }
    } catch (err) {
      setState((prev) => ({
        ...prev,
        error: err instanceof Error ? err.message : "Save failed",
      }));
      toast.error("Failed to save model");
    } finally {
      setState((prev) => ({ ...prev, saving: false }));
    }
  };

  const toggleFullscreen = () => {
    setIsFullscreen(prev => !prev);
  };

  // Conditional classes for the fullscreen mobile view
  const containerClasses = isFullscreen 
    ? "fixed inset-0 z-50 bg-background" 
    : "h-full w-full";

  return (
    <div className={containerClasses}>
      {isFullscreen && (
        <div className="absolute top-0 left-0 right-0 z-10 p-4 flex justify-between items-center bg-background/80 backdrop-blur-sm">
          <h2 className="text-lg font-medium">3D Model Viewer</h2>
          <Button
            variant="ghost"
            size="icon"
            onClick={toggleFullscreen}
          >
            <X className="h-5 w-5" />
          </Button>
        </div>
      )}
      
      <ProjectDialog
        open={projectDialogOpen}
        onOpenChange={setProjectDialogOpen}
        onProjectCreated={handleProjectCreated}
      />
      
      <div className={`${isMobile ? 'aspect-square w-full' : 'h-full w-full'}`}>
        <Canvas shadows camera={{ position: [0, 0, 5] }} style={{ background: bg }}>
          <color attach="background" args={[bg]} />
          <Suspense fallback={null}>
            <ModelContent url={url} onError={handleError} />
          </Suspense>
        </Canvas>
      </div>
      
      {/* Fullscreen button for mobile */}
      {isMobile && !isFullscreen && (
        <Button
          variant="outline"
          size="sm"
          className="absolute top-3 right-3 h-8 bg-background/50 backdrop-blur-sm z-10"
          onClick={toggleFullscreen}
        >
          <Expand className="h-3 w-3 mr-2" />
          Fullscreen
        </Button>
      )}
      
      {/* Controls positioned at the bottom */}
      <div className={`${isFullscreen ? 'absolute bottom-6' : 'absolute bottom-3'} left-0 right-0 flex justify-center gap-2 z-10 px-4`}>
        {/* Main controls */}
        <div className="flex gap-2 overflow-x-auto pb-2 max-w-full">
          <Button
            variant="outline"
            size="sm"
            className="h-8 bg-background/50 backdrop-blur-sm whitespace-nowrap"
            onClick={handleToggleTextures}
          >
            <Layers className="h-3 w-3 mr-2" />
            Toggle Textures
          </Button>
          
          <Button
            variant="outline"
            size="sm"
            className="h-8 bg-background/50 backdrop-blur-sm whitespace-nowrap"
            onClick={() => {
              const link = document.createElement("a")
              link.href = url
              link.download = "model.glb"
              document.body.appendChild(link)
              link.click()
              document.body.removeChild(link)
            }}
          >
            <Download className="h-3 w-3 mr-2" />
            Download
          </Button>
          
          {inputImage && resolution && (
            <>
              <div className="flex gap-1">
                <Select
                  value={selectedProjectId || undefined}
                  onValueChange={(value) => setSelectedProjectId(value)}
                >
                  <SelectTrigger className="h-8 text-xs bg-background/50 backdrop-blur-sm w-32">
                    <SelectValue placeholder="Select project" />
                  </SelectTrigger>
                  <SelectContent>
                    {projects.map((project) => (
                      <SelectItem key={project.id} value={project.id}>
                        {project.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                
                <Button
                  variant="outline"
                  size="icon"
                  className="h-8 w-8 bg-background/50 backdrop-blur-sm"
                  onClick={() => setProjectDialogOpen(true)}
                >
                  <FolderPlus className="h-3 w-3" />
                </Button>
              </div>
              
              <Button
                variant={state.saveSuccess ? "default" : "outline"}
                size="sm"
                className="h-8 bg-background/50 backdrop-blur-sm whitespace-nowrap"
                onClick={handleSaveModel}
                disabled={state.saving}
              >
                <Save className={`h-3 w-3 mr-2 ${state.saving ? "animate-spin" : ""}`} />
                {state.saving ? "Saving..." : state.saveSuccess ? "Saved" : "Save"}
              </Button>
            </>
          )}
        </div>
      </div>
      
      {state.error && (
        <Alert variant="destructive" className="absolute top-4 left-4 right-4">
          <AlertCircle className="h-4 w-4" />
          <AlertDescription>{state.error}</AlertDescription>
        </Alert>
      )}
    </div>
  )
}

/**
 * Converts a color temperature in Kelvin to an RGB string.
 */
function tempToColor(kelvin: number) {
  kelvin /= 100
  let red, green, blue
  if (kelvin <= 66) {
    red = 255
    green = Math.min(
      255,
      Math.max(0, 99.4708025861 * Math.log(kelvin) - 161.1195681661)
    )
    blue =
      kelvin <= 19
        ? 0
        : Math.min(
            255,
            Math.max(0, 138.5177312231 * Math.log(kelvin - 10) - 305.0447927307)
          )
  } else {
    red = Math.min(
      255,
      Math.max(0, 329.698727446 * Math.pow(kelvin - 60, -0.1332047592))
    )
    green = Math.min(
      255,
      Math.max(0, 288.1221695283 * Math.pow(kelvin - 60, -0.0755148492))
    )
    blue = 255
  }
  return `rgb(${red}, ${green}, ${blue})`
}
--------------------------------------------------------------------------------
File: components/mobile-gallery.tsx
================================================================================
// components/mobile-gallery.tsx
"use client";

import { X } from "lucide-react";
import { Button } from "@/components/ui/button";
import { PredictionsGrid } from "./predictions-grid";

interface MobileGalleryProps {
  isOpen: boolean;
  onClose: () => void;
  onSelectModel: (meshUrl: string, inputImage?: string, resolution?: number) => void;
  pendingSubmissions?: any[];
  currentProjectId?: string | null;
  onCreateProject?: () => void;
}

export function MobileGallery({ 
  isOpen, 
  onClose, 
  onSelectModel,
  pendingSubmissions = [],
  currentProjectId,
  onCreateProject
}: MobileGalleryProps) {
  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 bg-background flex flex-col">
      <div className="flex items-center justify-between p-4 border-b">
        <h2 className="text-lg font-medium">Gallery</h2>
        <Button variant="ghost" size="icon" onClick={onClose}>
          <X className="h-5 w-5" />
        </Button>
      </div>
      <div className="flex-1 overflow-y-auto p-4">
        <PredictionsGrid
          onSelectModel={(meshUrl, inputImage, resolution) => {
            onSelectModel(meshUrl, inputImage, resolution);
            onClose();
          }}
          showAll={true}
          pendingSubmissions={pendingSubmissions}
          currentProjectId={currentProjectId}
          onCreateProject={onCreateProject}
        />
      </div>
    </div>
  );
}
--------------------------------------------------------------------------------
File: components/theme-provider.tsx
================================================================================
"use client"

import { createContext, useContext, useEffect, useState } from "react"

type Theme = "dark" | "light"

type ThemeProviderProps = {
  children: React.ReactNode
}

const ThemeContext = createContext<{
  theme: Theme
  setTheme: (theme: Theme) => void
}>({
  theme: "dark",
  setTheme: () => null,
})

export function ThemeProvider({ children }: ThemeProviderProps) {
  const [theme, setTheme] = useState<Theme>("dark")

  useEffect(() => {
    // Check system theme
    const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)")
    setTheme(mediaQuery.matches ? "dark" : "light")

    // Listen for system theme changes
    const handler = (e: MediaQueryListEvent) => {
      setTheme(e.matches ? "dark" : "light")
    }
    mediaQuery.addEventListener("change", handler)
    return () => mediaQuery.removeEventListener("change", handler)
  }, [])

  useEffect(() => {
    document.documentElement.className = theme
  }, [theme])

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  )
}

export const useTheme = () => useContext(ThemeContext)

--------------------------------------------------------------------------------
File: components/navbar.tsx
================================================================================
"use client";

import { Github, LayoutGrid } from "lucide-react";
import Link from "next/link";
import Image from "next/image";
import { Button } from "@/components/ui/button";
import { useTheme } from "next-themes";
import { useEffect, useState } from "react";

interface NavbarProps {
  onOpenGallery?: () => void;
}

export function Navbar({ onOpenGallery }: NavbarProps) {
  const { resolvedTheme } = useTheme();
  const [mounted, setMounted] = useState(false);

  // Etter montering kan vi trygt vise logoen basert p친 temaet
  useEffect(() => {
    setMounted(true);
  }, []);

  const logoSrc =
    mounted && resolvedTheme === "dark"
      ? "https://i.ibb.co/v4wcBzGK/logo-darkmode.png"
      : "https://i.ibb.co/BV7rr4z2/logo-default.png";

  return (
    <div className="border-b">
      <div className="flex h-14 items-center px-4 max-w-screen-2xl mx-auto">
        <div className="flex items-center space-x-3">
          {mounted && (
            <div className="h-8 w-8 relative">
              <Image
                src={logoSrc}
                alt="ArchiFigure Logo"
                fill
                className="object-contain"
                unoptimized
              />
            </div>
          )}
          <div className="flex items-center space-x-2 font-semibold text-xl">
            <span className="bg-gradient-to-r from-blue-500 to-purple-600 text-transparent bg-clip-text">
              ArchiFigure.io
            </span>
            <span className="text-sm text-muted-foreground hidden md:inline-block">
               3D figures for architectural models
            </span>
          </div>
        </div>
        <div className="ml-auto flex items-center space-x-4">
          {onOpenGallery && (
            <Button
              variant="ghost"
              size="icon"
              className="md:flex"
              onClick={onOpenGallery}
            >
              <LayoutGrid className="h-5 w-5" />
            </Button>
          )}
          <Link
            href="https://github.com/your-username/your-repo"
            target="_blank"
            rel="noreferrer"
            className="text-sm text-muted-foreground hover:text-foreground transition-colors"
          >
            <Github className="h-5 w-5" />
          </Link>
        </div>
      </div>
    </div>
  );
}

--------------------------------------------------------------------------------
File: components/project-dialog.tsx
================================================================================
// components/project-dialog.tsx
"use client";

import { useState } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import { createProject } from "@/app/actions";
import { toast } from "sonner";

interface ProjectDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onProjectCreated: (projectId: string, projectName: string) => void;
}

export function ProjectDialog({ open, onOpenChange, onProjectCreated }: ProjectDialogProps) {
  const [projectName, setProjectName] = useState("");
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!projectName.trim()) {
      toast.error("Please enter a project name");
      return;
    }
    
    setLoading(true);
    
    try {
      const project = await createProject(projectName);
      
      if (project && project.id) {
        toast.success("Project created successfully");
        onProjectCreated(project.id, project.name);
        setProjectName("");
        onOpenChange(false);
      } else {
        toast.error("Failed to create project");
      }
    } catch (error) {
      console.error("Project creation error:", error);
      toast.error("An error occurred while creating the project");
    } finally {
      setLoading(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Lag nytt prosjekt</DialogTitle>
          <DialogDescription>
            skriv inn eitt namn for prosjektet
          </DialogDescription>
        </DialogHeader>
        
        <form onSubmit={handleSubmit}>
          <div className="grid gap-4 py-4">
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="project-name" className="text-right">
                Namn
              </Label>
              <Input
                id="project-name"
                value={projectName}
                onChange={(e) => setProjectName(e.target.value)}
                className="col-span-3"
                placeholder="My awesome project"
                autoComplete="off"
                autoFocus
              />
            </div>
          </div>
          
          <DialogFooter>
            <Button type="button" variant="outline" onClick={() => onOpenChange(false)}>
              Cancel
            </Button>
            <Button type="submit" disabled={loading || !projectName.trim()}>
              {loading ? "Creating..." : "Create Project"}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}
--------------------------------------------------------------------------------
File: components/ui/collapsible.tsx
================================================================================
"use client"

import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

const Collapsible = CollapsiblePrimitive.Root

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent

export { Collapsible, CollapsibleTrigger, CollapsibleContent }

--------------------------------------------------------------------------------
File: components/ui/tooltip.tsx
================================================================================
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Portal>
    <TooltipPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 overflow-hidden rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </TooltipPrimitive.Portal>
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }

--------------------------------------------------------------------------------
File: components/ui/tabs.tsx
================================================================================
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-9 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }

--------------------------------------------------------------------------------
File: components/ui/dialog.tsx
================================================================================
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}

--------------------------------------------------------------------------------
File: components/ui/button.tsx
================================================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

--------------------------------------------------------------------------------
File: components/ui/label.tsx
================================================================================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }

--------------------------------------------------------------------------------
File: components/ui/card.tsx
================================================================================
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

--------------------------------------------------------------------------------
File: components/ui/input.tsx
================================================================================
import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }

--------------------------------------------------------------------------------
File: components/ui/badge.tsx
================================================================================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }

--------------------------------------------------------------------------------
File: components/ui/slider.tsx
================================================================================
"use client"

import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-1.5 w-full grow overflow-hidden rounded-full bg-primary/20">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-4 w-4 rounded-full border border-primary/50 bg-background shadow transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }

--------------------------------------------------------------------------------
File: components/ui/select.tsx
================================================================================
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}

--------------------------------------------------------------------------------
File: components/ui/textarea.tsx
================================================================================
import * as React from "react"

import { cn } from "@/lib/utils"

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<"textarea">
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-base shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Textarea.displayName = "Textarea"

export { Textarea }

--------------------------------------------------------------------------------
File: components/ui/checkbox.tsx
================================================================================
"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary shadow focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }

--------------------------------------------------------------------------------
File: components/ui/alert.tsx
================================================================================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground [&>svg~*]:pl-7",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }

--------------------------------------------------------------------------------
File: node_modules/react-dropzone/typings/tests/file-dialog.tsx
================================================================================
import React from "react";
import Dropzone from "../../";

export const dropzone = (
  <Dropzone
    onDrop={(files) => console.log(files)}
    onFileDialogCancel={() => console.log("onFileDialogCancel invoked")}
    onFileDialogOpen={() => console.log("onFileDialogOpen invoked")}
  >
    {({ getRootProps, getInputProps, open }) => (
      <div {...getRootProps()}>
        <input {...getInputProps()} />
        <p>Drop some files here.</p>
        <button type="button" onClick={open}>
          Open file dialog
        </button>
      </div>
    )}
  </Dropzone>
);

--------------------------------------------------------------------------------
File: node_modules/react-dropzone/typings/tests/hook.tsx
================================================================================
import React from "react";
import { useDropzone, DropzoneProps } from "../../";

export const Dropzone = ({ children, ...opts }: DropzoneProps) => {
  const { ...state } = useDropzone(opts);
  return children(state);
};

<Dropzone>
  {({ getRootProps, getInputProps }) => (
    <div {...getRootProps()}>
      <input {...getInputProps()} />
    </div>
  )}
</Dropzone>;

--------------------------------------------------------------------------------
File: node_modules/react-dropzone/typings/tests/accept.tsx
================================================================================
import React from "react";
import Dropzone from "../../";

export default class Accept extends React.Component {
  state = {
    accepted: [],
    rejected: [],
  };

  render() {
    return (
      <section>
        <div className="dropzone">
          <Dropzone
            accept={{
              "image/*": [".jpeg", ".png"],
            }}
            onDrop={(accepted, rejected) => {
              this.setState({ accepted, rejected });
            }}
          >
            {({ getRootProps }) => (
              <div {...getRootProps()}>
                <p>
                  Try dropping some files here, or click to select files to
                  upload.
                </p>
                <p>Only *.jpeg and *.png images will be accepted</p>
              </div>
            )}
          </Dropzone>
        </div>
        <aside>
          <h2>Accepted files</h2>
          <ul>
            {this.state.accepted.map((f) => (
              <li key={f.name}>
                {f.name} - {f.size} bytes
              </li>
            ))}
          </ul>
          <h2>Rejected files</h2>
          <ul>
            {this.state.rejected.map((f) => (
              <li key={f.name}>
                {f.name} - {f.size} bytes
              </li>
            ))}
          </ul>
        </aside>
      </section>
    );
  }
}

--------------------------------------------------------------------------------
File: node_modules/react-dropzone/typings/tests/all.tsx
================================================================================
import React from "react";
import Dropzone from "../../";

export default class Test extends React.Component {
  render() {
    return (
      <div>
        <Dropzone
          onDrop={(acceptedFiles, fileRejections, event) =>
            console.log(acceptedFiles, fileRejections, event)
          }
          onDragEnter={(event) => console.log(event)}
          onDragOver={(event) => console.log(event)}
          onDragLeave={(event) => console.log(event)}
          onDropAccepted={(files, event) => console.log(files, event)}
          onDropRejected={(files, event) => console.log(files, event)}
          onFileDialogCancel={() => console.log("onFileDialogCancel invoked")}
          onFileDialogOpen={() => console.log("onFileDialogOpen invoked")}
          onError={(e) => console.log(e)}
          validator={(f) => ({ message: f.name, code: "" })}
          minSize={2000}
          maxSize={Infinity}
          maxFiles={100}
          preventDropOnDocument
          noClick={false}
          noKeyboard={false}
          noDrag={false}
          noDragEventsBubbling={false}
          disabled
          multiple={false}
          accept={{
            "image/*": [".png"],
          }}
          useFsAccessApi={false}
          autoFocus
        >
          {({ getRootProps, getInputProps }) => (
            <div {...getRootProps()}>
              <input {...getInputProps()} />
            </div>
          )}
        </Dropzone>
      </div>
    );
  }
}

--------------------------------------------------------------------------------
File: node_modules/react-dropzone/typings/tests/refs.tsx
================================================================================
import React, { createRef } from "react";
import Dropzone, { DropzoneRef } from "../../";

const ref = createRef<DropzoneRef>();

export const dropzone = (
  <Dropzone ref={ref}>
    {({ getRootProps, getInputProps }) => (
      <div {...getRootProps()}>
        <input {...getInputProps()} />
        <p>Drop some files here.</p>
        <button type="button" onClick={ref.current.open}>
          Open file dialog
        </button>
      </div>
    )}
  </Dropzone>
);

--------------------------------------------------------------------------------
File: node_modules/react-dropzone/typings/tests/plugin.tsx
================================================================================
import React, { Component } from "react";
import Dropzone from "../../";

export class TestReactDragEvt extends Component {
  getFiles = async (event: React.DragEvent<HTMLDivElement>) => {
    const files = Array.from(event.dataTransfer.files);
    return files;
  };

  render() {
    return (
      <div>
        <Dropzone getFilesFromEvent={this.getFiles}>
          {({ getRootProps }) => <div {...getRootProps()} />}
        </Dropzone>
      </div>
    );
  }
}

export class TestDataTransferItems extends Component {
  getFiles = async (event: React.DragEvent<HTMLDivElement>) => {
    const items = Array.from(event.dataTransfer.items);
    return items;
  };

  render() {
    return (
      <div>
        <Dropzone getFilesFromEvent={this.getFiles}>
          {({ getRootProps }) => <div {...getRootProps()} />}
        </Dropzone>
      </div>
    );
  }
}

export class TestNativeDragEventEvt extends Component {
  getFiles = async (event: DragEvent) => {
    const files = Array.from(event.dataTransfer.files);
    return files;
  };

  render() {
    return (
      <div>
        <Dropzone getFilesFromEvent={this.getFiles}>
          {({ getRootProps }) => <div {...getRootProps()} />}
        </Dropzone>
      </div>
    );
  }
}

export class TestChangeEvt extends Component {
  getFiles = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const files = Array.from(event.target.files);
    return files;
  };

  render() {
    return (
      <div>
        <Dropzone getFilesFromEvent={this.getFiles}>
          {({ getRootProps }) => <div {...getRootProps()} />}
        </Dropzone>
      </div>
    );
  }
}

export class TestNativeEvt extends Component {
  getFiles = async (event: Event) => {
    const files = Array.from((event.target as HTMLInputElement).files);
    return files;
  };

  render() {
    return (
      <div>
        <Dropzone getFilesFromEvent={this.getFiles}>
          {({ getRootProps }) => <div {...getRootProps()} />}
        </Dropzone>
      </div>
    );
  }
}

--------------------------------------------------------------------------------
File: node_modules/react-dropzone/typings/tests/basic.tsx
================================================================================
import React from "react";
import Dropzone from "../../";
import { FileWithPath } from "file-selector";

export default class Basic extends React.Component {
  state = { files: [] };

  onDrop = (files: FileWithPath[]) => {
    this.setState({
      files,
    });
  };

  render() {
    return (
      <section>
        <div className="dropzone">
          <Dropzone onDrop={this.onDrop}>
            {({ getRootProps, getInputProps }) => (
              <div {...getRootProps()}>
                <input {...getInputProps()} />
                <p>
                  Try dropping some files here, or click to select files to
                  upload.
                </p>
              </div>
            )}
          </Dropzone>
        </div>
        <aside>
          <h2>Dropped files</h2>
          <ul>
            {this.state.files.map((f) => (
              <li key={f.name}>
                {f.name} - {f.size} bytes
              </li>
            ))}
          </ul>
        </aside>
      </section>
    );
  }
}

export const optional = (
  <Dropzone>
    {({ getRootProps, getInputProps }) => (
      <div {...getRootProps()}>
        <input {...getInputProps()} />
      </div>
    )}
  </Dropzone>
);

--------------------------------------------------------------------------------
File: node_modules/react-dropzone/typings/tests/events.tsx
================================================================================
import React from "react";
import Dropzone from "../../";

export class Events extends React.Component {
  render() {
    return (
      <section>
        <div className="dropzone">
          <Dropzone
            onDrop={(acceptedFiles, fileRejections, event) =>
              console.log(acceptedFiles, fileRejections, event)
            }
            onDragEnter={(event) => console.log(event)}
            onDragOver={(event) => console.log(event)}
            onDragLeave={(event) => console.log(event)}
          >
            {({ getRootProps, getInputProps }) => (
              <div {...getRootProps()}>
                <input {...getInputProps()} />
                <p>
                  Try dropping some files here, or click to select files to
                  upload.
                </p>
              </div>
            )}
          </Dropzone>
        </div>
      </section>
    );
  }
}

--------------------------------------------------------------------------------
File: node_modules/its-fine/src/index.tsx
================================================================================
import * as React from 'react'
import type ReactReconciler from 'react-reconciler'

/**
 * An SSR-friendly useLayoutEffect.
 *
 * React currently throws a warning when using useLayoutEffect on the server.
 * To get around it, we can conditionally useEffect on the server (no-op) and
 * useLayoutEffect elsewhere.
 *
 * @see https://github.com/facebook/react/issues/14927
 */
const useIsomorphicLayoutEffect =
  typeof window !== 'undefined' && (window.document?.createElement || window.navigator?.product === 'ReactNative')
    ? React.useLayoutEffect
    : React.useEffect

/**
 * Represents a react-internal Fiber node.
 */
export type Fiber<T = any> = Omit<ReactReconciler.Fiber, 'stateNode'> & { stateNode: T }

/**
 * Represents a {@link Fiber} node selector for traversal.
 */
export type FiberSelector<T = any> = (
  /** The current {@link Fiber} node. */
  node: Fiber<T | null>,
) => boolean | void

/**
 * Traverses up or down a {@link Fiber}, return `true` to stop and select a node.
 */
export function traverseFiber<T = any>(
  /** Input {@link Fiber} to traverse. */
  fiber: Fiber | undefined,
  /** Whether to ascend and walk up the tree. Will walk down if `false`. */
  ascending: boolean,
  /** A {@link Fiber} node selector, returns the first match when `true` is passed. */
  selector: FiberSelector<T>,
): Fiber<T> | undefined {
  if (!fiber) return
  if (selector(fiber) === true) return fiber

  let child = ascending ? fiber.return : fiber.child
  while (child) {
    const match = traverseFiber(child, ascending, selector)
    if (match) return match

    child = ascending ? null : child.sibling
  }
}

// In development, React will warn about using contexts between renderers.
// Hide the warning because its-fine fixes this issue
// https://github.com/facebook/react/pull/12779
function wrapContext<T>(context: React.Context<T>): React.Context<T> {
  try {
    return Object.defineProperties(context, {
      _currentRenderer: {
        get() {
          return null
        },
        set() {},
      },
      _currentRenderer2: {
        get() {
          return null
        },
        set() {},
      },
    })
  } catch (_) {
    return context
  }
}

const error = console.error
console.error = function () {
  const message = [...arguments].join('')
  if (message?.startsWith('Warning:') && message.includes('useContext')) {
    console.error = error
    return
  }

  return error.apply(this, arguments as any)
}

const FiberContext = wrapContext(React.createContext<Fiber>(null!))

/**
 * A react-internal {@link Fiber} provider. This component binds React children to the React Fiber tree. Call its-fine hooks within this.
 */
export class FiberProvider extends React.Component<{ children?: React.ReactNode }> {
  private _reactInternals!: Fiber

  render() {
    return <FiberContext.Provider value={this._reactInternals}>{this.props.children}</FiberContext.Provider>
  }
}

/**
 * Returns the current react-internal {@link Fiber}. This is an implementation detail of [react-reconciler](https://github.com/facebook/react/tree/main/packages/react-reconciler).
 */
export function useFiber(): Fiber<null> | undefined {
  const root = React.useContext(FiberContext)
  if (root === null) throw new Error('its-fine: useFiber must be called within a <FiberProvider />!')

  const id = React.useId()
  const fiber = React.useMemo(() => {
    for (const maybeFiber of [root, root?.alternate]) {
      if (!maybeFiber) continue
      const fiber = traverseFiber<null>(maybeFiber, false, (node) => {
        let state = node.memoizedState
        while (state) {
          if (state.memoizedState === id) return true
          state = state.next
        }
      })
      if (fiber) return fiber
    }
  }, [root, id])

  return fiber
}

/**
 * Represents a react-reconciler container instance.
 */
export interface ContainerInstance<T = any> {
  containerInfo: T
}

/**
 * Returns the current react-reconciler container info passed to {@link ReactReconciler.Reconciler.createContainer}.
 *
 * In react-dom, a container will point to the root DOM element; in react-three-fiber, it will point to the root Zustand store.
 */
export function useContainer<T = any>(): T | undefined {
  const fiber = useFiber()
  const root = React.useMemo(
    () => traverseFiber<ContainerInstance<T>>(fiber, true, (node) => node.stateNode?.containerInfo != null),
    [fiber],
  )

  return root?.stateNode.containerInfo
}

/**
 * Returns the nearest react-reconciler child instance or the node created from {@link ReactReconciler.HostConfig.createInstance}.
 *
 * In react-dom, this would be a DOM element; in react-three-fiber this would be an instance descriptor.
 */
export function useNearestChild<T = any>(
  /** An optional element type to filter to. */
  type?: keyof JSX.IntrinsicElements,
): React.MutableRefObject<T | undefined> {
  const fiber = useFiber()
  const childRef = React.useRef<T>()

  useIsomorphicLayoutEffect(() => {
    childRef.current = traverseFiber<T>(
      fiber,
      false,
      (node) => typeof node.type === 'string' && (type === undefined || node.type === type),
    )?.stateNode
  }, [fiber])

  return childRef
}

/**
 * Returns the nearest react-reconciler parent instance or the node created from {@link ReactReconciler.HostConfig.createInstance}.
 *
 * In react-dom, this would be a DOM element; in react-three-fiber this would be an instance descriptor.
 */
export function useNearestParent<T = any>(
  /** An optional element type to filter to. */
  type?: keyof JSX.IntrinsicElements,
): React.MutableRefObject<T | undefined> {
  const fiber = useFiber()
  const parentRef = React.useRef<T>()

  useIsomorphicLayoutEffect(() => {
    parentRef.current = traverseFiber<T>(
      fiber,
      true,
      (node) => typeof node.type === 'string' && (type === undefined || node.type === type),
    )?.stateNode
  }, [fiber])

  return parentRef
}

export type ContextMap = Map<React.Context<any>, any> & {
  get<T>(context: React.Context<T>): T | undefined
}

/**
 * Returns a map of all contexts and their values.
 */
export function useContextMap(): ContextMap {
  const fiber = useFiber()
  const [contextMap] = React.useState(() => new Map<React.Context<any>, any>())

  // Collect live context
  contextMap.clear()
  let node = fiber
  while (node) {
    if (node.type && typeof node.type === 'object') {
      // https://github.com/facebook/react/pull/28226
      const enableRenderableContext = node.type._context === undefined && node.type.Provider === node.type
      const context = enableRenderableContext ? node.type : node.type._context
      if (context && context !== FiberContext && !contextMap.has(context)) {
        contextMap.set(context, React.useContext(wrapContext(context)))
      }
    }

    node = node.return!
  }

  return contextMap
}

/**
 * Represents a react-context bridge provider component.
 */
export type ContextBridge = React.FC<React.PropsWithChildren<{}>>

/**
 * React Context currently cannot be shared across [React renderers](https://reactjs.org/docs/codebase-overview.html#renderers) but explicitly forwarded between providers (see [react#17275](https://github.com/facebook/react/issues/17275)). This hook returns a {@link ContextBridge} of live context providers to pierce Context across renderers.
 *
 * Pass {@link ContextBridge} as a component to a secondary renderer to enable context-sharing within its children.
 */
export function useContextBridge(): ContextBridge {
  const contextMap = useContextMap()

  // Flatten context and their memoized values into a `ContextBridge` provider
  return React.useMemo(
    () =>
      Array.from(contextMap.keys()).reduce(
        (Prev, context) => (props) =>
          (
            <Prev>
              <context.Provider {...props} value={contextMap.get(context)} />
            </Prev>
          ),
        (props) => <FiberProvider {...props} />,
      ),
    [contextMap],
  )
}

--------------------------------------------------------------------------------
File: node_modules/tunnel-rat/src/index.tsx
================================================================================
import React, { ReactNode } from 'react'
import { create, StoreApi } from 'zustand'
import { useIsomorphicLayoutEffect } from './utils'

type Props = { children: React.ReactNode }

type State = {
  current: Array<React.ReactNode>
  version: number
  set: StoreApi<State>['setState']
}

export default function tunnel() {
  const useStore = create<State>((set) => ({
    current: new Array<ReactNode>(),
    version: 0,
    set,
  }))

  return {
    In: ({ children }: Props) => {
      const set = useStore((state) => state.set)
      const version = useStore((state) => state.version)

      /* When this component mounts, we increase the store's version number.
      This will cause all existing rats to re-render (just like if the Out component
      were mapping items to a list.) The re-rendering will cause the final 
      order of rendered components to match what the user is expecting. */
      useIsomorphicLayoutEffect(() => {
        set((state) => ({
          version: state.version + 1,
        }))
      }, [])

      /* Any time the children _or_ the store's version number change, insert
      the specified React children into the list of rats. */
      useIsomorphicLayoutEffect(() => {
        set(({ current }) => ({
          current: [...current, children],
        }))

        return () =>
          set(({ current }) => ({
            current: current.filter((c) => c !== children),
          }))
      }, [children, version])

      return null
    },

    Out: () => {
      const current = useStore((state) => state.current)
      return <>{current}</>
    },
  }
}

--------------------------------------------------------------------------------
File: node_modules/tunnel-rat/test/tunnelrat.test.tsx
================================================================================
import '@testing-library/jest-dom'
import { fireEvent, render, screen } from '@testing-library/react'
import React from 'react'
import tunnel from '../src'

describe('tunnelrat', () => {
  it('transports the children of In into Out', () => {
    const t = tunnel()

    const Outlet = () => (
      <ul>
        <t.Out />
      </ul>
    )

    const Inlets = () => (
      <div>
        <t.In>
          <li>One</li>
        </t.In>
      </div>
    )

    const { container } = render(
      <>
        <Outlet />
        <Inlets />
      </>
    )

    expect(container).toMatchInlineSnapshot(`
      <div>
        <ul>
          <li>
            One
          </li>
        </ul>
        <div />
      </div>
    `)
  })

  it('can handle multiple children', () => {
    const t = tunnel()

    const Outlet = () => (
      <ul>
        <t.Out />
      </ul>
    )

    const Inlets = () => (
      <div>
        <t.In>
          <li>One</li>
        </t.In>
        <t.In>
          <li>Two</li>
        </t.In>
      </div>
    )

    const { container } = render(
      <>
        <Outlet />
        <Inlets />
      </>
    )

    expect(container).toMatchInlineSnapshot(`
      <div>
        <ul>
          <li>
            One
          </li>
          <li>
            Two
          </li>
        </ul>
        <div />
      </div>
    `)
  })

  it('retains the expected order of multiple children after un- and remounts', () => {
    const t = tunnel()

    const Rat = ({ name }: { name: string }) => {
      const [visible, setVisible] = React.useState(true)

      return (
        <div>
          <button onClick={() => setVisible(!visible)}>Toggle {name}</button>
          {visible ? (
            <t.In>
              <li>{name}</li>
            </t.In>
          ) : null}
        </div>
      )
    }

    const Outlet = () => (
      <ul>
        <t.Out />
      </ul>
    )

    const Inlets = () => (
      <div>
        <Rat name="One" />
        <Rat name="Two" />
        <Rat name="Three" />
      </div>
    )

    const { container } = render(
      <>
        <Outlet />
        <Inlets />
      </>
    )

    expect(container).toMatchInlineSnapshot(`
      <div>
        <ul>
          <li>
            One
          </li>
          <li>
            Two
          </li>
          <li>
            Three
          </li>
        </ul>
        <div>
          <div>
            <button>
              Toggle 
              One
            </button>
          </div>
          <div>
            <button>
              Toggle 
              Two
            </button>
          </div>
          <div>
            <button>
              Toggle 
              Three
            </button>
          </div>
        </div>
      </div>
    `)

    /* Remove the middle rat */
    fireEvent.click(screen.getByText('Toggle Two'))

    expect(container).toMatchInlineSnapshot(`
      <div>
        <ul>
          <li>
            One
          </li>
          <li>
            Three
          </li>
        </ul>
        <div>
          <div>
            <button>
              Toggle 
              One
            </button>
          </div>
          <div>
            <button>
              Toggle 
              Two
            </button>
          </div>
          <div>
            <button>
              Toggle 
              Three
            </button>
          </div>
        </div>
      </div>
    `)

    /* Re-add it */
    fireEvent.click(screen.getByText('Toggle Two'))

    /* The "Two" rat gets re-added, and at the top of the list. */
    expect(container).toMatchInlineSnapshot(`
      <div>
        <ul>
          <li>
            One
          </li>
          <li>
            Two
          </li>
          <li>
            Three
          </li>
        </ul>
        <div>
          <div>
            <button>
              Toggle 
              One
            </button>
          </div>
          <div>
            <button>
              Toggle 
              Two
            </button>
          </div>
          <div>
            <button>
              Toggle 
              Three
            </button>
          </div>
        </div>
      </div>
    `)
  })
})

--------------------------------------------------------------------------------
